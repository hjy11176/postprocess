c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e,eg

      udiff =0.
      utrans=0.

      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'NEKUSE'          ! FF[XYZ]
      include 'PARALLEL'        ! GLLEL
      include 'SOLN'            ! V[XYZ]
      integer ix,iy,iz,ieg
      ffx = 0.0
      ffy = 0.0
      ffz = 0.0
	  
	  
!     add tripping
      call trip_forcing(ffx,ffy,ffz,ix,iy,iz,ieg)

!     add sponge at the outlet
!      call spng_forcing(FFX,FFY,FFZ,ix,iy,iz,ieg)


      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e,eg

      qvol   = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
!      implicit none
      include 'SIZE'            !
      include 'TOTAL'            !
!      include 'TSTEP'           ! ISTEP, lastep, time
!      include 'INPUT'           ! IF3D, PARAM
      parameter (lt=lx1*ly1*lz1*lelt)
      real l2(lx1,ly1,lz1,nelt)
      common /scrns/ vort(lt,3),w1(lt)
     &               ,w2(lt)
      common /myoutflow/ d(lx1,ly1,lz1,lelt),m1(lx1*ly1*lz1,lelt)

!      common /myblas/ ub(lx1,ly1,lz1,lelt),vb(lx1,ly1,lz1,lelt)
!      common /scrns/    dum(lx1*ly1*lz1*lelv)
!      common /blasiusr/ u(lx1,ly1,lz1,lelv),v(lx1,ly1,lz1,lelv)
!      common /blasiusg/ bin(lx1,ly1,lz1,lelv)
      common /gaaa/    wo1(lx1,ly1,lz1,lelv)
     &              ,  wo2(lx1,ly1,lz1,lelv)
     &              ,  wo3(lx1,ly1,lz1,lelv)
      integer bin
      real normu(50),normv(50)


      real xmax,xmin,dx
      save xmax,xmin,dx

!      n = nx1*ny1*nz1*nelv

c
!      real m1
!      rq  = 1.
!      uin = 0.
! 	  call turb_outflow(d,m1,rq,uin)


c     Compute delta*

c      do i=1,n
c         dum(i) = 1.-vx(i,1,1,1)
c      enddo
c      tot_deficit = glsc2(dum,bm1,n)
c      xmin        = glmin(xm1,n)
c      xmax        = glmax(xm1,n)
c      delta_star  = tot_deficit/(xmax-xmin)
c      if (nid.eq.0) write(6,1) istep,time,delta_star,xmin,xmax
c    1 format(i8,1p4e13.5,'  blasius: delta*')





!     start framework
      if (istep.eq.0) call frame_start

!     monitor simulation
      call frame_monitor

!     save/load files for full-restart
      call chkpt_main

!     for tripping
      call trip_update

!     finalise framework
      if (istep.eq.nsteps.or.lastep.eq.1) then
         call frame_end
      endif

      if(ifoutfld.and.istep.gt.1000) then
c      if(ifoutfld) then
        if (ldimt.ge.32) call lambda2(t(1,1,1,1,32))
        if (ldimt.ge.33) call comp_vort3(t(1,1,1,1,33),wo1,wo2,vx,vy,vz)
      endif

      call my_avg_all 
	   param(68) =50000
     


!     write out probes
      if (mod(ISTEP,10).eq.0) call hpts()
!     outpost vorticity and lambda2 
      call comp_vort3(vort,w1,w2,vx,vy,vz)
      call lambda2(L2)
      if (mod(ISTEP,49999).eq.1) call outpost(vort(1,1),
     &                  vort(1,2),vort(1,3),pr,t,'vrt')
     
!     convert the binary data to readable form
      call gfldr('../tesblasius0.f00001')
 
!     write velocity gradient	
      call gradm1(dudx,dudy,dudz,vx)
      call gradm1(dvdx,dvdy,dvdz,vy)
      call gradm1(dwdx,dwdy,dwdz,vz)

!     write stress tensor
      do ie=1,nelv
         call comp_gije(sij,vx(1,1,1,ie),vy(1,1,1,ie),vz(1,1,1,ie),ie) !compute the gradient tensor
         call comp_sije(sij) !compute symetric part of the tensor
         call my_mag_tensor_e(ss(1,1,1,ie),sij(1,1,1,1,1)) !compute magnitude of the tensor
         call cmult(ss(1,1,1,ie),2.0,nxyz) !multiplyby a constant
      enddo

!    write reynolds stress
      do j=1,nxyz*nelv
        uu(j)=u(j)*u(j)
        uv(j)=u(j)*v(j)
        uz(j)=u(j)*w(j)
        vv(j)=v(j)*v(j)
        vw(j)=v(j)*w(j)
        ww(j)=w(j)*w(j)
      enddo

!    write the x, y, z, reynolds stress file
      call outpost(dudx,dvdx,dwdx,dpdx,t,'grx')
      call outpost(dudy,dvdy,dwdy,dpdy,t,'gry')
      call outpost(dudz,dvdz,dwdz,dpdz,t,'grz')
      call outpost(uu,uv,uz,vv,vw,ww,'res')

      call copy(dudx,dudx1,nxyz*nelv)
      call copy(dvdx,dvdx1,nxyz*nelv)
      call copy(dwdx,dwdx1,nxyz*nelv)
      call copy(dpdx,dpdx1,nxyz*nelv)
      call copy(t,t1,nxyz*nelv)
      call copy(dudy,dudy1,nxyz*nelv)
      call copy(dvdy,dvdy1,nxyz*nelv)
      call copy(dwdy,dwdy1,nxyz*nelv)
      call copy(dudz,dudz1,nxyz*nelv)
      call copy(dvdz,dvdz1,nxyz*nelv)
      call copy(dwdz,dwdz1,nxyz*nelv)
     
      call copy(blasius.box,blasius1.box,nxyz*nelv)
      call copy(blasius.ma2,blasius1.ma2,nxyz*nelv)
      call copy(blasuis.re2,blasius1.re2,nxyz*nelv)
      call copy(SIZE,SIZE1,nxyz*nelv)
      call copy(CHKPOINTD,CHKPOINTD1,nxyz*nelv)
      call copy(CHKPTMSTPD,CHKPTMSTPD1,nxyz*nelv)
      call copy(FRAMELP,FRAMELP1,nxyz*nelv)
      call copy(IOTOOLD,IOTOOLD1,nxyz*nelv)
      call copy(MNTRLOGD,MNTRLOGD1,nxyz*nelv)
      call copy(MNTRTMRD,MNTRTMRD1,nxyz*nelv)
      call copy(RPRMD,RPRMD1,nxyz*nelv)
      call copy(SPONGEBXD,SPONGEBXD1,nxyz*nelv)
      call copy(TRIPD,TRIPD1,nxyz*nelv)
      call copy(nek_interpolation/interpolation/blasius.usr,nek_interpolation/interpolation/blasius1.usr,nxyz*nelv)

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e,eg, myfield
      common /myblas/ ub(lx1,ly1,lz1,lelt),vb(lx1,ly1,lz1,lelt)
      common /myphol/ thetat(lx1,ly1,lz1,lelt,ldimt) 

      real amp,freq,xi,xp,xf,lambda2, lp

      e  = gllel(eg)
      myfield = ifield-1
      if (cbc(iside,e,ifield).eq.'v  ') then
      ux = ub(ix,iy,iz,e)
      uy = vb(ix,iy,iz,e)
      uz = 0.0
      endif
      if (cbc(iside,e,ifield).eq.'o  ') then
         U0 = 1.0
         delta = 0.01               ! small positive constant
         pa = p_outflow(ix,iy,iz,e,iside,U0,delta)
      endif



      if(iside.eq.3) then
        if (cbc(3,e,ifield).eq.'t  ') then 
           temp= 0
        endif
      endif

      if(iside.eq.4) then
        if (cbc(4,e,ifield).eq.'t  ') then 
c           if(myfield.le.32) temp= thetat(ix,iy,iz,e,myfield)
c           if(myfield.ge.17) temp= thetaf(ix,iy,iz,e,myfield-16)
           temp= 0
           
        endif
      endif


      if(iside.eq.1) then
        if (cbc(1,e,ifield).eq.'t  ') then
c           if (x.le.xk) then 
c              temp = x/xk  
c           else   
              temp = 1
c           endif
        endif
        endif


      if(iside.eq.1) then
        if (cbc(1,e,ifield).eq.'f  ') then 
           flux= -1
        endif
      endif



      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e,eg,myfield

      common /myblas/ ub(lx1,ly1,lz1,lelt),vb(lx1,ly1,lz1,lelt)
      common /myphol/ thetat(lx1,ly1,lz1,lelt, ldimt)
c     &                thetaf(lx1,ly1,lz1,lelt, (ldimt-2)/2)
      real amplitude,perturb,px1,px2,py1,py2

      myfield = ifield-1
      e  = gllel(eg)
      if (ifield.eq.1) then
      ux = ub(ix,iy,iz,e)
      uy = vb(ix,iy,iz,e)
      uz = 0
      else

c      if(myfield.le.32) temp= thetat(ix,iy,iz,e,myfield)
c      if(myfield.ge.17.and.myfield.le.32)
c     &                  temp= thetaf(ix,iy,iz,e,myfield-16)
           


      temp=0
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'

      common /myblas/ ub(lx1,ly1,lz1,lelt),vb(lx1,ly1,lz1,lelt)
      common /myphol/ thetat(lx1,ly1,lz1,lelt,ldimt)
c     &                thetaf(lx1,ly1,lz1,lelt,(ldimt-2)/2)
      save /myphol/ 
c      common /blasius_data/ f_blasius, f_prime
      real Prh((ldimt-2)/2) 

      data Prh / 2,1.e2, 1, 0.71, 0.5, 0.35, 0.3, 0.25, 0.2, 0.1,
     $  0.0237, 0.0413, 0.0232, 0.0210,0.0107, 0.0085/!, 0.0058 /
c      y0 = 0
c      y1 = 10
c      call rescale_x(ym1,y0,y1) ! Put y on [0,10]

      call set_blasius(ub,vb) ! Compute the Blasius profile for I.C.
c      do j = 1, (ldimt-2)/2
c      call set_theta(thetat(1,1,1,1,j)
c     &              , thetat(1,1,1,1,j+(ldimt-2)/2), Prh(j)) ! Compute the Pohlhausen profile for I.C.
c      enddo
      
c      call outpost2 (ub,vb,pr,pr,thetat,ldimt,'thr') 
c     call outpost2 (ub,vb,ub,vb,thetaf,ldimt,'th2')
      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      return
      end
c-----------------------------------------------------------------------
      subroutine set_blasius(ub,vb) ! Compute the Blasius profile
      include 'SIZE'
      include 'TOTAL'

      real ub(1),vb(1)
c      real f_dummy, fp_dummy

      n = nx1*ny1*nz1*nelv

      visc = 1.8138e-5
c      delta99_0 = 5.0/1.7208
      delta_star= 1
      u_0   = 1

      x_0 = (delta_star/1.7208)**2 / visc * u_0  ! Reference x 
c      x_inflow = (605.0/740.0)**2 * x_0
      x_inflow = x_0 

      do i=1,n
         x = xm1(i,1,1,1)
         y = ym1(i,1,1,1)

         x_t = x_inflow + x
         rex = u_0 * x_t / visc
         eta = y*sqrt(rex)/x_t

         call blasius(ub(i),vb(i),eta,rex)

      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine set_theta(thetat, thetaf, Prh)
      include 'SIZE'
      include 'TOTAL'
c      common /blasius_data/ f_blasius, f_prime
      real thetat(1), thetaf(1)
      real Prh
      integer n, i, j
c      real dummy_u, dummy_v
c      real fb, fpb

      n = nx1 * ny1 * nz1 * nelv
      visc = 1.8138e-5
c      delta99_0 = 5.0/1.7208
      delta_star= 1
      u_0   = 1

      x_0 = (delta_star/1.7208)**2 / visc * u_0  ! Reference x
c      x_inflow = (605.0/740.0)**2 * x_0
      x_inflow = x_0

          do i = 1, n
              x = xm1(i, 1, 1, 1)
              y = ym1(i, 1, 1, 1)

              x_t = x_inflow + x
              rex = u_0 * x_t / visc
              eta = y * sqrt(rex) / x_t
c            !Update f_blasius and f_prime for the current eta
c              call blasius(dummy_u, dummy_v, eta, rex,fb,fpb)
c              fb = 0.5 
c              fpb = 0.7 
              call theta_profile(thetat(i),thetaf(i), 
     &                           eta, Prh)
          enddo

      return
      end
c-----------------------------------------------------------------------
      SUBROUTINE SPLINE(X,Y,N,YP1,YPN,Y2)
      PARAMETER (NMAX=100)
      DIMENSION X(N),Y(N),Y2(N),U(NMAX)
      IF (YP1.GT..99E30) THEN
        Y2(1)=0.
        U(1)=0.
      ELSE
        Y2(1)=-0.5
        U(1)=(3./(X(2)-X(1)))*((Y(2)-Y(1))/(X(2)-X(1))-YP1)
      ENDIF
      DO 11 I=2,N-1
        SIG=(X(I)-X(I-1))/(X(I+1)-X(I-1))
        P=SIG*Y2(I-1)+2.
        Y2(I)=(SIG-1.)/P
        U(I)=(6.*((Y(I+1)-Y(I))/(X(I+1)-X(I))-(Y(I)-Y(I-1))
     *      /(X(I)-X(I-1)))/(X(I+1)-X(I-1))-SIG*U(I-1))/P
11    CONTINUE
      IF (YPN.GT..99E30) THEN
        QN=0.
        UN=0.
      ELSE
        QN=0.5
        UN=(3./(X(N)-X(N-1)))*(YPN-(Y(N)-Y(N-1))/(X(N)-X(N-1)))
      ENDIF
      Y2(N)=(UN-QN*U(N-1))/(QN*Y2(N-1)+1.)
      DO 12 K=N-1,1,-1
        Y2(K)=Y2(K)*Y2(K+1)+U(K)
12    CONTINUE
      RETURN
      END
      SUBROUTINE SPLINT(XA,YA,Y2A,N,X,Y)
      DIMENSION XA(N),YA(N),Y2A(N)
      KLO=1
      KHI=N
1     IF (KHI-KLO.GT.1) THEN
        K=(KHI+KLO)/2
        IF(XA(K).GT.X)THEN
          KHI=K
        ELSE
          KLO=K
        ENDIF
      GOTO 1
      ENDIF
      H=XA(KHI)-XA(KLO)
      IF (H.EQ.0.) PAUSE 'Bad XA input.'
      A=(XA(KHI)-X)/H
      B=(X-XA(KLO))/H
      Y=A*YA(KLO)+B*YA(KHI)+
     *      ((A**3-A)*Y2A(KLO)+(B**3-B)*Y2A(KHI))*(H**2)/6.
      RETURN
      END
c-----------------------------------------------------------------------
      subroutine theta_profile(thetat, thetaf, eta, Prh)
      integer icalld
      save icalld
      data icalld /0/
c      common /blasius_data/ f_blasius, f_prime
      parameter (lb=100)
      real thetat_soln(0:3,0:lb)
c      save thetat_soln
      real thetaf_soln(0:3,0:lb)
c      save thetaf_soln

      real wt(3)
      real wf(3)
      twok2 =  1.6551903602308323382003140460740
      rk2   =  0.5*twok2
      rk    =  sqrt(rk2)
      if (icalld.eq.0) then
          icalld = 1

          call set_ics_thetat(thetat_soln(0,0))
          call set_ics_thetaf(thetaf_soln(0,0))

          dt = .05
          rr = 1.0725
          do i = 1, lb
              thetat_soln(0, i) = thetat_soln(0, i-1) + dt
              thetaf_soln(0, i) = thetaf_soln(0, i-1) + dt
              dt = dt * rr
          enddo

          do i = 1, lb
              eta0t = thetat_soln(0, i-1)
              eta1t = thetat_soln(0, i)
              t0t = 0.5 * eta0t / rk
              t1t = 0.5 * eta1t / rk
              eta0f = thetaf_soln(0, i-1)
              eta1f = thetaf_soln(0, i)
              t0f = 0.5 * eta0f / rk
              t1f = 0.5 * eta1f / rk
              dt = .0005
              m = 2
              call copy(thetat_soln(1, i), thetat_soln(1, i-1), m)
              call copy(thetaf_soln(1, i), thetaf_soln(1, i-1), m)
              call rk4_integrate_thetat(thetat_soln(1, i), 2, t1t, 
     &         t0t, dt, Prh)
              call rk4_integrate_thetaf(thetaf_soln(1, i), 2, t1f, 
     &         t0f, dt, Prh)
     
          enddo
      endif

      if (eta.gt.thetat_soln(0, lb)) then
          call copy(wt, thetat_soln(1, lb), 2)
      else
          i = interval_find(eta, thetat_soln, 4, lb)
          eta0t = thetat_soln(0, i)
          t0t = 0.5 * eta0t / rk
          t1t = 0.5 * eta / rk
          dt = .0005
          m = 2
          call copy(wt, thetat_soln(1, i), m)
          call rk4_integrate_thetat(wt, 2, t1t, t0t, dt, Prh)
      endif

      if (eta.gt.thetaf_soln(0, lb)) then
          call copy(wf, thetaf_soln(1, lb), 2)
      else
          i = interval_find(eta, thetaf_soln, 4, lb)
          eta0f = thetaf_soln(0, i)
          t0f = 0.5 * eta0f / rk
          t1f = 0.5 * eta / rk
          dt = .0005
          m = 2
          call copy(wf, thetaf_soln(1, i), m)
          call rk4_integrate_thetaf(wf, 2, t1f, t0f, dt, Prh)
      endif

      thetat = wt(1)/rk

c      thetaf = wf(1)/(rk*450*Prh)
      thetaf = wf(1)/rk 
      return
      end
c-----------------------------------------------------------------------
      subroutine rk4_integrate_thetat(w,n,tfinal,tstart,dti,Prh)
      real w(n)
c      common /blasius_data/ f_blasius, f_prime
      if (tfinal.gt.tstart .and. dti.gt.0.) then
          tdelta = tfinal - tstart
          dt = dti
          nsteps = tdelta / dt
          nsteps = max(nsteps, 1)
          dt = tdelta / nsteps

          t = tstart
          do k = 1, nsteps
              call rk4_thetat(w, t, dt, n, Prh)
              t = t + dt
          enddo
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine rk4_integrate_thetaf(w,n,tfinal,tstart,dti,Prh)
      real w(n)
c      common /blasius_data/ f_blasius, f_prime
      if (tfinal.gt.tstart .and. dti.gt.0.) then
          tdelta = tfinal - tstart
          dt = dti
          nsteps = tdelta / dt
          nsteps = max(nsteps, 1)
          dt = tdelta / nsteps

          t = tstart
          do k = 1, nsteps
              call rk4_thetaf(w, t, dt, n, Prh)
              t = t + dt
          enddo
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine rk4_thetat(w, t, dt, n, Prh)
c      common /blasius_data/ f_blasius, f_prime
      real w(1), t, dt
      real wh(3), f1(3), f2(3), f3(3), f4(3)

      dt2 = dt / 2.
      dt3 = dt / 3.
      dt6 = dt / 6.

      t2 = t + dt2
      tt = t + dt

      call compute_f_thetat(f1, w, t, Prh)
      call add3s2nd(wh, w, f1, dt2, n)

      call compute_f_thetat(f2, wh, t2,Prh)
      call add3s2nd(wh, w, f2, dt2, n)

      call compute_f_thetat(f3, wh, t2,Prh)
      call add3s2nd(wh, w, f3, dt, n)

      call compute_f_thetat(f4, wh, tt,Prh)

      do i = 1, n
          w(i) = w(i) + dt6 * (f1(i) + f4(i)) + dt3 * (f2(i) + f3(i))
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine rk4_thetaf(w, t, dt, n, Prh)
c      common /blasius_data/ f_blasius, f_prime
      real w(1), t, dt
      real wh(3), f1(3), f2(3), f3(3), f4(3)

      dt2 = dt / 2.
      dt3 = dt / 3.
      dt6 = dt / 6.

      t2 = t + dt2
      tt = t + dt

      call compute_f_thetaf(f1, w, t, Prh)
      call add3s2nd(wh, w, f1, dt2, n)

      call compute_f_thetaf(f2, wh, t2, Prh)
      call add3s2nd(wh, w, f2, dt2, n)

      call compute_f_thetaf(f3, wh, t2, Prh)
      call add3s2nd(wh, w, f3, dt, n)

      call compute_f_thetaf(f4, wh, tt, Prh)

      do i = 1, n
          w(i) = w(i) + dt6 * (f1(i) + f4(i)) + dt3 * (f2(i) + f3(i))
      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine blasius(u,v,eta,rex)
c      common /blasius_data/ f_blasius, f_prime
      integer icalld
      save    icalld
      data    icalld /0/

      parameter (lb=100)
      real blasius_soln(0:4,0:lb)
      save blasius_soln
c
c     Algorithm found in Lighthill's monograph on mathematical fluid mech.
c     (c. of M. Choudhari)
c
      real  w(4)

      twok2 =  1.6551903602308323382003140460740
      rk2   =  0.5*twok2
      rk    =  sqrt(rk2)

      if (icalld.eq.0) then
         icalld = 1

         call set_ics (blasius_soln(0,0))

         dt=.05
         rr=1.0725
         do i=1,lb
            blasius_soln(0,i) = blasius_soln(0,i-1) + dt
            dt = dt*rr
         enddo

         do i=1,lb
            eta0 = blasius_soln(0,i-1)
            eta1 = blasius_soln(0,i  )
            t0 = 0.5*eta0/rk
            t1 = 0.5*eta1/rk
            dt = .0005    !  Note, this is good to about 12 digits
            m=3
            call copy(blasius_soln(1,i),blasius_soln(1,i-1),m)
            call rk4_integrate(blasius_soln(1,i),3,t1,t0,dt)
         enddo
      endif

      if (eta.gt.blasius_soln(0,lb)) then

         call copy(w,blasius_soln(1,lb),2)

      else

         i = interval_find(eta,blasius_soln,5,lb)

         eta0 = blasius_soln(0,i)
         t0   = 0.5*eta0/rk
         t1   = 0.5*eta/rk
         dt   = .0005    !  Note, this is good to about 12 digits
         m    = 3
         call copy(w,blasius_soln(1,i),m)
         call rk4_integrate(w,3,t1,t0,dt)

      endif

      g  = w(1)
      gp = w(2)

      fb  = g  / rk
      fpb = gp / twok2
      
      u  = fpb
      v  = 0.5*(eta*fpb-fb)/sqrt(rex)
c      f_blasius = f
c      f_prime = fp
c     write(6,1) eta,u,v,f,fp,rex
c  1  format(1p6e14.6,' eta')

      return
      end
c-----------------------------------------------------------------------
      subroutine rk4_integrate(w,n,tfinal,tstart,dti)

c     Program to integrate dW/dt = F(W,t)

      real  w(n)

c     Input:   w() is initial condition at t=tstart
c     Output:  w() is solution at t = tfinal
c
c     n = length of vector

      if (tfinal.gt.tstart .and. dti.gt.0.) then

         tdelta = tfinal-tstart
         dt     = dti
         nsteps = tdelta/dt
         nsteps = max(nsteps,1)
         dt     = tdelta/nsteps

         t = tstart
         do k=1,nsteps !  TIME STEPPING

            call rk4 (w,t,dt,n) ! Single RK4 step (nmax=4)
            t = t+dt

         enddo

      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine set_ics (w)
      real  w(0:3)

c     Initial conditions for modified Blasius equation g''' + g g'' = 0

      w(0) = 0    ! eta = 0
      w(1) = 0    ! g
      w(2) = 0    ! g'
      w(3) = 1    ! g"

      return
      end
c-----------------------------------------------------------------------
      subroutine set_ics_thetat(w)
      real w(0:2)

c      Initial conditions for Pohlhausen equation g'' + Pr f(eta) g' = 0

      w(0) = 0    ! eta = 0
      w(1) = 0    ! theta
      w(2) = 1    ! theta'
      return
      end
c-----------------------------------------------------------------------
      subroutine set_ics_thetaf(w)
      real w(0:2)

c      Initial conditions for Pohlhausen equation g'' + Pr f(eta) g' = 0

      w(0) = 0    ! eta = 0
      w(1) = 0    ! theta
      w(2) = 1    ! theta'
      return
      end
c-----------------------------------------------------------------------
      subroutine compute_f(f,w,t)
c
c     Compute RHS of ODE:
c
c
      real  f(4),w(4)
c
      f(1) = w(2)
      f(2) = w(3)
      f(3) = -w(1)*w(3)
c
      return
      end
c-----------------------------------------------------------------------
      subroutine compute_f_thetat(f, w, t, Prh)
      real f(3), w(3)
c      common /blasius_data/ f_blasius, f_prime

      f(1) = w(2)
      f(2) = -Prh * fbf(t) * w(2)

      return
      end
c-----------------------------------------------------------------------
      real function fbf(eta)
      real eta
      fbf= eta-2.0
      if(eta.lt.4) fbf=0.125*eta**2
      end
c-----------------------------------------------------------------------
      real function fpbf(eta)
      real eta
      fpbf= 1.0
      if(eta.lt.4) fpbf=0.25*eta
      end
c-----------------------------------------------------------------------
      subroutine compute_f_thetaf(f, w, t, Prh)
      real f(3), w(3)
c      common /blasius_data/ f_blasius, f_prime

      f(1) = w(2)
      f(2) = -Prh * (fbf(t) * w(2) + (1-w(1))*fpbf(t))

      return
      end
c-----------------------------------------------------------------------
      subroutine add3s2nd(x,y,z,c,n)
      real  x(1),y(1),z(1),c
c
      do i=1,n
         x(i) = y(i) + c*z(i)
      enddo
      return
      end
c-----------------------------------------------------------------------
      subroutine rk4(w,t,dt,n)
      real  w(1),t,dt
      real  wh(4),f1(4),f2(4),f3(4),f4(4)

c     RK4:

      dt2 = dt/2.
      dt3 = dt/3.
      dt6 = dt/6.

      t2 = t+dt2
      tt = t+dt

      call compute_f (f1,w ,t )
      call add3s2nd  (wh,w,f1,dt2,n)

      call compute_f (f2,wh,t2)
      call add3s2nd  (wh,w,f2,dt2,n)

      call compute_f (f3,wh,t2)
      call add3s2nd  (wh,w,f3,dt ,n)

      call compute_f (f4,wh,tt)

      do i=1,n
         w(i) = w(i) + dt6*(f1(i)+f4(i)) + dt3*(f2(i)+f3(i))
      enddo

      return
      end
c-----------------------------------------------------------------------
      function interval_find(x,xa,m,n)

c     Find interval. p. 88-89, numerical recipes

      real xa(m,0:n)

      if (x.ge.xa(1,n)) then

         interval_find = n

      elseif (x.le.xa(1,0)) then

         interval_find = 0

      else

         klo=0
         khi=n
    1    if ((khi-klo).gt.1) then
           k=(khi+klo)/2
           if (xa(1,k).gt.x) then
              khi=k
           else
              klo=k
           endif
           goto 1
         endif
c
         h=xa(1,khi)-xa(1,klo)
         if (h.eq.0) then
            write(6,*) xa(1,klo),xa(1,khi),klo,khi
     $                 ,'ERROR: Zero jump in interval_find.'
            return
         endif

         interval_find = klo

      endif

      return
      end


!======================================================================
!						my_avg_all
!======================================================================
c-----------------------------------------------------------------------
      subroutine my_avg_all
c
c     This routine computes running averages E(X),E(X^2),E(X*Y)
c     and outputs to avg*.fld*, rms*.fld*, and rm2*.fld* for all
c     fields.
c
c     E denotes the expected value operator and X,Y two
c     real valued random variables.
c
c     variances and covariances can be computed in a post-processing step:
c
c        var(X)   := E(X^2) - E(X)*E(X) 
c        cov(X,Y) := E(X*Y) - E(X)*E(Y)  
c        cos(X,Y,Z)=E[(x−E[X])(y−E[Y])(z−E[Z])]
c
c     Note: The E-operator is linear, in the sense that the expected
c           value is given by E(X) = 1/N * sum[ E(X)_i ], where E(X)_i
c           is the expected value of the sub-ensemble i (i=1...N).
c
      include 'SIZE'  
      include 'TOTAL' 
      include 'AVG'

	   real tums(ax1,ay1,az1,lelt,ldimt)
	   real tvms(ax1,ay1,az1,lelt,ldimt)
	   real twms(ax1,ay1,az1,lelt,ldimt)
c     strain rate variables definitions {{{
      real sij(ax1,ay1,az1,ldim,ldim)
     $   , ss(ax1,ay1,az1,lelt)
     $   , ssavg(ax1,ay1,az1,lelt)
      common /usreps/ ssavg
c     }}}
c     Temperature dissipation {{{
      real dtdx(ax1,ay1,az1,lelt,ldimt)
     $   , dtdy(ax1,ay1,az1,lelt,ldimt)
     $   , dtdz(ax1,ay1,az1,lelt,ldimt)
     $   , epstt(ax1,ay1,az1,lelt,ldimt)
     $   , epsttavg(ax1,ay1,az1,lelt,ldimt)
      common /usrepstt/ epsttavg
c     }}}
c     gradient variables definitions {{{
      real uavgx(ax1,ay1,az1,lelt)
     $   , vavgx(ax1,ay1,az1,lelt)
     $   , wavgx(ax1,ay1,az1,lelt)
     $   , tavgx(ax1,ay1,az1,lelt,ldimt)
     $   , pavgx(ax2,ay2,az2,lelt)

      real uavgy(ax1,ay1,az1,lelt)
     $   , vavgy(ax1,ay1,az1,lelt)
     $   , wavgy(ax1,ay1,az1,lelt)
     $   , tavgy(ax1,ay1,az1,lelt,ldimt)
     $   , pavgy(ax2,ay2,az2,lelt)

      real uavgz(ax1,ay1,az1,lelt)
     $   , vavgz(ax1,ay1,az1,lelt)
     $   , wavgz(ax1,ay1,az1,lelt)
     $   , tavgz(ax1,ay1,az1,lelt,ldimt)
     $   , pavgz(ax2,ay2,az2,lelt)
      common /usrgrad/ uavgx, uavgy, uavgz
     $   , vavgx, vavgy, vavgz
     $   , wavgx, wavgy, wavgz
     $   , tavgx, tavgy, tavgz
     $   , pavgx, pavgy, pavgz
c     }}}

c     Turbulent dissipation {{{
      real uvws(ax1,ay1,az1,lelt)
     $   , uvvs(ax1,ay1,az1,lelt)
     $   , uwws(ax1,ay1,az1,lelt)
     $   , uuvs(ax1,ay1,az1,lelt)
     $   , uuws(ax1,ay1,az1,lelt)
     $   , uuus(ax1,ay1,az1,lelt)
     $   , vvvs(ax1,ay1,az1,lelt)
     $   , wwws(ax2,ay2,az2,lelt)
     $   , vvws(ax1,ay1,az1,lelt)
     $   , vwws(ax1,ay1,az1,lelt)
     $   , uvts(ax1,ay1,az1,lelt,ldimt)
     $   , uwts(ax1,ay1,az1,lelt,ldimt)
     $   , uuts(ax1,ay1,az1,lelt,ldimt)
     $   , vvts(ax1,ay1,az1,lelt,ldimt)
     $   , wwts(ax1,ay1,az1,lelt,ldimt)
     $   , vwts(ax1,ay1,az1,lelt,ldimt)
      common /turbdis/ uvws, uvvs, uwws, uuvs, uuws, uuus, vvvs, wwws,
     $   vvws, vwws, uvts, uwts, uuts, vvts, wwts, vwts    
c     }}}

c     Viscous dissipation {{{
      real epsxxavg(ax1,ay1,az1,lelt)
     $   , epsyyavg(ax1,ay1,az1,lelt)
     $   , epszzavg(ax1,ay1,az1,lelt)
     $   , epsxyavg(ax1,ay1,az1,lelt)
     $   , epsxzavg(ax1,ay1,az1,lelt)
     $   , epsyzavg(ax1,ay1,az1,lelt)
     $   , epsxx(ax1,ay1,az1,lelt)
     $   , epsyy(ax1,ay1,az1,lelt)
     $   , epszz(ax1,ay1,az1,lelt)
     $   , epsxy(ax1,ay1,az1,lelt)
     $   , epsxz(ax1,ay1,az1,lelt)
     $   , epsyz(ax1,ay1,az1,lelt)
     $   , epstxavg(ax1,ay1,az1,lelt,ldimt)
     $   , epstyavg(ax2,ay2,az2,lelt,ldimt)
     $   , epstzavg(ax1,ay1,az1,lelt,ldimt)
c     $   , epstpavg(ax1,ay1,az1,lelt,ldimt)
     $   , epstx(ax1,ay1,az1,lelt,ldimt)
     $   , epsty(ax2,ay2,az2,lelt,ldimt)
     $   , epstz(ax1,ay1,az1,lelt,ldimt)
c     $   , epstv(ax1,ay1,az1,lelt,ldimt)

      common /viscdis/ epsxxavg, epsyyavg, epszzavg, epsxyavg, epsxzavg,
     $     epsyzavg, epstxavg, epstyavg, epstzavg, 
     $     epstx, epsty, epstz, epsxx, epsyy,epszz, epsxy, epsxz, epsyz
c     }}}
      
c     Molecular diffusion {{{
      real udtdx(ax1,ay1,az1,lelt,ldimt)
     $   , udtdy(ax1,ay1,az1,lelt,ldimt)
     $   , udtdz(ax1,ay1,az1,lelt,ldimt)
     $   , vdtdx(ax1,ay1,az1,lelt,ldimt)
     $   , vdtdy(ax1,ay1,az1,lelt,ldimt)
     $   , vdtdz(ax1,ay1,az1,lelt,ldimt)
     $   , tdudx(ax1,ay1,az1,lelt,ldimt)
     $   , tdudy(ax1,ay1,az1,lelt,ldimt)
     $   , tdudz(ax1,ay1,az1,lelt,ldimt)
     $   , tdvdx(ax1,ay1,az1,lelt,ldimt)
     $   , tdvdy(ax1,ay1,az1,lelt,ldimt)
     $   , tdvdz(ax1,ay1,az1,lelt,ldimt)
      common /moldis/ udtdx, udtdy, udtdz, vdtdx, vdtdy, vdtdz, 
     $                tdudx, tdudy, tdudz, tdvdx, tdvdy, tdvdz 
c     }}}

c     Pressure {{{ 
      real ptms(ax1,ay1,az1,lelt,ldimt)
     $   , upms(ax1,ay1,az1,lelt)
     $   , vpms(ax1,ay1,az1,lelt)
     $   , wpms(ax1,ay1,az1,lelt)
     $   , pdux(ax1,ay1,az1,lelt)
     $   , pdvx(ax1,ay1,az1,lelt)
     $   , pdwx(ax1,ay1,az1,lelt)
     $   , pduy(ax1,ay1,az1,lelt)
     $   , pdvy(ax1,ay1,az1,lelt)
     $   , pdwy(ax1,ay1,az1,lelt)
     $   , pduz(ax1,ay1,az1,lelt)
     $   , pdvz(ax1,ay1,az1,lelt)
     $   , pdwz(ax1,ay1,az1,lelt)
     $   , pdtx(ax1,ay1,az1,lelt,ldimt)
     $   , pdty(ax1,ay1,az1,lelt,ldimt)
     $   , pdtz(ax1,ay1,az1,lelt,ldimt)
      common /pressure/ ptms, upms, vpms, wpms, pdtx, pdty, pdtz,
     $        pdux,pdvx,pdwx,pduy,pdvy,pdwy,pduz,pdvz,pdwz
c     }}}

c     Velocity gradients {{{
      real dudx(ax1,ay1,az1,lelt,ldimt)
     $   , dudy(ax1,ay1,az1,lelt)
     $   , dudz(ax1,ay1,az1,lelt)
     $   , dvdx(ax1,ay1,az1,lelt)
     $   , dvdy(ax1,ay1,az1,lelt)
     $   , dvdz(ax1,ay1,az1,lelt)
     $   , dwdx(ax1,ay1,az1,lelt)
     $   , dwdy(ax1,ay1,az1,lelt)
     $   , dwdz(ax1,ay1,az1,lelt)
      common /vgrad/ dudx, dudy, dudz, dvdx, dvdy, dvdz, dwdx
     $              , dwdy, dwdz
c     }}}

c     Integrals of dissipation {{{
      real idiss
      real totvol
      real avu, avv, avw
c     }}}
      logical ifverbose
      integer icalld
      save    icalld
      data    icalld  /0/

      if (ax1.ne.lx1 .or. ay1.ne.ly1 .or. az1.ne.lz1) then
         if(nid.eq.0) write(6,*)
     $     'ABORT: wrong size of ax1,ay1,az1 in avg_all(), check SIZE!'
         call exitt
      endif
      if (ax2.ne.lx2 .or. ay2.ne.ay2 .or. az2.ne.lz2) then
         if(nid.eq.0) write(6,*)
     $     'ABORT: wrong size of ax2,ay2,az2 in avg_all(), check SIZE!'
         call exitt
      endif

      ntot  = lx1*ly1*lz1*nelv
      ntott = lx1*ly1*lz1*nelt
      nto2  = lx2*ly2*lz2*nelv
      nxyz = nx1*ny1*nz1

      ! initialization
      if (icalld.eq.0) then
         icalld = icalld + 1
         atime  = 0.
         timel  = time

         call rzero(uavg,ntot)
         call rzero(vavg,ntot)
         call rzero(wavg,ntot)
         call rzero(pavg,nto2)
         do i = 1,ldimt
            call rzero(tavg(1,1,1,1,i),ntott)
         enddo

         call rzero(urms,ntot)
         call rzero(vrms,ntot)
         call rzero(wrms,ntot)
         call rzero(prms,nto2)
         do i = 1,ldimt
            call rzero(trms(1,1,1,1,i),ntott)
         enddo

         call rzero(vwms,ntot)
         call rzero(wums,ntot)
         call rzero(uvms,ntot)
         call rzero(ssavg,ntot)
         do i = 1,ldimt
            call rzero(epsttavg(1,1,1,1,i),ntott)
         enddo
        
!============================================
! call emppty arrays for tums
!============================================
         do i = 1,ldimt
            call rzero(tums(1,1,1,1,i),ntott)
            call rzero(tvms(1,1,1,1,i),ntott)
            call rzero(twms(1,1,1,1,i),ntott)
         enddo
         totvol = glsum(bm1,ntott)
         if(nio.eq.0) write(6,10) totvol
   10    format(' totvol =',1pe16.8)

      endif

      dtime = time  - timel
      atime = atime + dtime

      ! dump freq
      iastep = param(68)
      if  (iastep.eq.0) iastep=param(15)   ! same as iostep
      if  (iastep.eq.0) iastep=500

      ifverbose=.false.
      if (istep.le.10) ifverbose=.true.
      if  (mod(istep,iastep).eq.0) ifverbose=.true.

      if (atime.ne.0..and.dtime.ne.0.) then
         if(nio.eq.0) write(6,*) 'Compute statistics ...'
         beta  = dtime/atime
         alpha = 1.-beta
         ! compute averages E(X)
         call avg1    (uavg,vx,alpha,beta,ntot ,'um  ',ifverbose)
         call avg1    (vavg,vy,alpha,beta,ntot ,'vm  ',ifverbose)
         call avg1    (wavg,vz,alpha,beta,ntot ,'wm  ',ifverbose)
         call avg1    (pavg,pr,alpha,beta,nto2 ,'prm ',ifverbose)
         call avg1    (tavg,t ,alpha,beta,ntott,'tm  ',ifverbose)
         do i = 2,ldimt
            call avg1 (tavg(1,1,1,1,i),t(1,1,1,1,i),alpha,beta,
     &                 ntott,'psav',ifverbose)
         enddo
c     Calculate gradients from average values {{{
         do i=1,ldimt
            call gradm1(tavgx(1,1,1,1,i),tavgy(1,1,1,1,i),
     $         tavgz(1,1,1,1,i), tavg(1,1,1,1,i))
         enddo
         if(nio.eq.0) write(6,*) 'grad temp calculation done ...'

            call gradm1(uavgx(1,1,1,1),uavgy(1,1,1,1),uavgz(1,1,1,1),
     $         uavg(1,1,1,1))
            call gradm1(vavgx(1,1,1,1),vavgy(1,1,1,1),vavgz(1,1,1,1),
     $         vavg(1,1,1,1))
            call gradm1(wavgx(1,1,1,1),wavgy(1,1,1,1),wavgz(1,1,1,1),
     $         wavg(1,1,1,1))
            call gradm1(pavgx(1,1,1,1),pavgy(1,1,1,1),pavgz(1,1,1,1),
     $         pavg(1,1,1,1))
         if(nio.eq.0) write(6,*) 'vel and pressure calculation done ...'
c     }}} 


         ! compute averages E(X^2) 
         call avg2    (urms,vx,alpha,beta,ntot ,'ums ',ifverbose)
         call avg2    (vrms,vy,alpha,beta,ntot ,'vms ',ifverbose)
         call avg2    (wrms,vz,alpha,beta,ntot ,'wms ',ifverbose)
         call avg2    (prms,pr,alpha,beta,nto2 ,'prms',ifverbose)
         call avg2    (trms,t ,alpha,beta,ntott,'tms ',ifverbose)
         do i = 2,ldimt
            call avg2 (trms(1,1,1,1,i),t(1,1,1,1,i),alpha,beta,
     &                 ntott,'psms',ifverbose)
         enddo


         ! compute averages E(X*Y) 
         call avg3    (uvms,vx,vy,alpha,beta,ntot,'uvm ',ifverbose)
         call avg3    (vwms,vy,vz,alpha,beta,ntot,'vwm ',ifverbose)
         call avg3    (wums,vz,vx,alpha,beta,ntot,'wum ',ifverbose)

         do i = 1,ldimt
            call avg3 (tums(1,1,1,1,i),vx,t(1,1,1,1,i),alpha,beta,
     &                 ntott,'tvx ',ifverbose)

            call avg3 (tvms(1,1,1,1,i),vy,t(1,1,1,1,i),alpha,beta,
     &                 ntott,'tvy ',ifverbose)

            call avg3 (twms(1,1,1,1,i),vz,t(1,1,1,1,i),alpha,beta,
     &                 ntott,'tvz ',ifverbose)
            call avg3 (ptms(1,1,1,1,i),pr,t(1,1,1,1,i),alpha,beta,
     &                 ntott,'ptm ',ifverbose)
         enddo

         call avg3    (upms,vx,pr,alpha,beta,ntot,'upm ',ifverbose)
         call avg3    (vpms,vy,pr,alpha,beta,ntot,'vpm ',ifverbose)
         call avg3    (wpms,vz,pr,alpha,beta,ntot,'wpm ',ifverbose)
         
         ! compute averages E(X*Y*Z)--> third-order central cross moment
         ! cos(X,Y,Z)=E[(x−E[X])(y−E[Y])(z−E[Z])]  (Coskewness)

         ! Turbulent transport by fluctuating velocity (diffusion term)
         call avg4    (uvws,vx,vy,vz,alpha,beta,ntot,'uvw ',ifverbose)
         call avg4    (uuus,vx,vx,vx,alpha,beta,ntot,'uuu ',ifverbose)
         call avg4    (vvvs,vy,vy,vy,alpha,beta,ntot,'vvv ',ifverbose)
         call avg4    (wwws,vz,vz,vz,alpha,beta,ntot,'www ',ifverbose)
         call avg4    (uvvs,vx,vy,vy,alpha,beta,ntot,'uvv ',ifverbose)
         call avg4    (uuvs,vx,vx,vy,alpha,beta,ntot,'uuv ',ifverbose)
         call avg4    (uwws,vx,vz,vz,alpha,beta,ntot,'uww ',ifverbose)
         call avg4    (uuws,vx,vx,vz,alpha,beta,ntot,'uuw ',ifverbose)
         call avg4    (vwws,vy,vz,vz,alpha,beta,ntot,'vww ',ifverbose)
         call avg4    (vvws,vy,vy,vz,alpha,beta,ntot,'vvw ',ifverbose)


         ! Turbulent diffusion term
         do i = 1,ldimt
         call avg4    (uvts(1,1,1,1,i),vx,vy,t(1,1,1,1,i),alpha,beta,
     &                 ntot,'uvt ',ifverbose)
         call avg4    (uwts(1,1,1,1,i),vx,vz,t(1,1,1,1,i),alpha,beta,
     &                 ntot,'uwt ',ifverbose)
         call avg4    (uuts(1,1,1,1,i),vx,vx,t(1,1,1,1,i),alpha,beta,
     &                 ntot,'uut ',ifverbose)
         call avg4    (vvts(1,1,1,1,i),vy,vy,t(1,1,1,1,i),alpha,beta,
     &                 ntot,'vvt ',ifverbose)
         call avg4    (wwts(1,1,1,1,i),vz,vz,t(1,1,1,1,i),alpha,beta,
     &                 ntot,'wwt ',ifverbose)
         call avg4    (vwts(1,1,1,1,i),vy,vz,t(1,1,1,1,i),alpha,beta,
     &                 ntot,'vwt ',ifverbose)
         enddo


      do ie=1,nelv
         call comp_gije(sij,vx(1,1,1,ie),vy(1,1,1,ie),vz(1,1,1,ie),ie) !compute the gradient tensor
         call comp_sije(sij) !compute symetric part of the tensor
         call my_mag_tensor_e(ss(1,1,1,ie),sij(1,1,1,1,1)) !compute magnitude of the tensor
         call cmult(ss(1,1,1,ie),2.0,nxyz) !multiplyby a constant
      enddo
         call avg1(ssavg,ss,alpha,beta,ntot,'ss  ',ifverbose)

         call gradm1(dudx,dudy,dudz,vx)
         call gradm1(dvdx,dvdy,dvdz,vy)
         call gradm1(dwdx,dwdy,dwdz,vz)      

         do i=1,ldimt
            call gradm1(dtdx(1,1,1,1,i),dtdy(1,1,1,1,i),
     $         dtdz(1,1,1,1,i), t(1,1,1,1,i))

            call vdot3(epstt(1,1,1,1,i)
     $         ,dtdx(1,1,1,1,i),dtdy(1,1,1,1,i),dtdz(1,1,1,1,i)
     $         ,dtdx(1,1,1,1,i),dtdy(1,1,1,1,i),dtdz(1,1,1,1,i)
     $         ,ntott)
c            call vdot3(epstv(1,1,1,1,i),pr,pr,pr,dtdx(1,1,1,1,i),
c     $                 dtdy(1,1,1,1,i),dtdz(1,1,1,1,i))
            call vdot3(epstx(1,1,1,1,i),dudx,dudy,dudz,dtdx(1,1,1,1,i),
     $                 dtdy(1,1,1,1,i),dtdz(1,1,1,1,i))
            call vdot3(epsty(1,1,1,1,i),dvdx,dvdy,dvdz,dtdx(1,1,1,1,i),
     $                 dtdy(1,1,1,1,i),dtdz(1,1,1,1,i))
            call vdot3(epstz(1,1,1,1,i),dwdx,dwdy,dwdz,dtdx(1,1,1,1,i),
     $                 dtdy(1,1,1,1,i),dtdz(1,1,1,1,i))
c            call vdot3(disudt(1,1,1,1,i),vx,vx,vx,dtdx(1,1,1,1,i),
c     $                 dtdy(1,1,1,1,i),dtdz(1,1,1,1,i))
c            call vdot3(disvdt(1,1,1,1,i),vy,vy,vy,dtdx(1,1,1,1,i),
c     $                 dtdy(1,1,1,1,i),dtdz(1,1,1,1,i))
c            call vdot3(diswdt(1,1,1,1,i),vz,vz,vz,dtdx(1,1,1,1,i),
c     $                 dtdy(1,1,1,1,i),dtdz(1,1,1,1,i))
c            call vdot3(distdu(1,1,1,1,i),t(1,1,1,1,i),dudx,dudy,dudz)
c            call vdot3(distdv(1,1,1,1,i),t(1,1,1,1,i),dvdx,dvdy,dvdz)
c            call vdot3(distdw(1,1,1,1,i),t(1,1,1,1,i),dwdx,dwdy,dwdz)
      ! pressure scrambling term 
            call avg3 (pdtx(1,1,1,1,i),pr,dtdx(1,1,1,1,i),alpha,beta,
     &                 ntott,'ptx ',ifverbose)
            call avg3 (pdty(1,1,1,1,i),pr,dtdy(1,1,1,1,i),alpha,beta,
     &                 ntott,'pty ',ifverbose)
            call avg3 (pdtz(1,1,1,1,i),pr,dtdz(1,1,1,1,i),alpha,beta,
     &                 ntott,'ptz ',ifverbose)
         enddo
         call vdot3(epsxx,dudx,dudy,dudz,dudx,dudy,dudz)
         call vdot3(epsyy,dvdx,dvdy,dvdz,dvdx,dvdy,dvdz)
         call vdot3(epszz,dwdx,dwdy,dwdz,dwdx,dwdy,dwdz)
         call vdot3(epsxy,dudx,dudy,dudz,dvdx,dvdy,dvdz)
         call vdot3(epsxz,dudx,dudy,dudz,dwdx,dwdy,dwdz)
         call vdot3(epsyz,dvdx,dvdy,dvdz,dwdx,dwdy,dwdz)
      do i=1,ldimt
         call avg1(epsttavg(1,1,1,1,i),epstt,alpha,beta,ntott,'ett ',
     &            ifverbose)
         ! dissipation term Eps_thetai
         call avg1(epstxavg(1,1,1,1,i),epstx,alpha,beta,ntott,'etx ',
     &    ifverbose)
         call avg1(epstyavg(1,1,1,1,i),epsty,alpha,beta,ntott,'ety ',
     &    ifverbose)
         call avg1(epstzavg(1,1,1,1,i),epstz,alpha,beta,ntott,'etz ',
     &    ifverbose)
      enddo
         ! dissipation term Eps_ij
         call avg1(epsxxavg,epsxx,alpha,beta,ntott,'exx ',ifverbose)
         call avg1(epsyyavg,epsyy,alpha,beta,ntott,'eyy ',ifverbose)
         call avg1(epszzavg,epszz,alpha,beta,ntott,'ezz ',ifverbose)
         call avg1(epsxyavg,epsxy,alpha,beta,ntott,'exy ',ifverbose)
         call avg1(epsxzavg,epsxz,alpha,beta,ntott,'exz ',ifverbose)
         call avg1(epsyzavg,epsyz,alpha,beta,ntott,'eyz ',ifverbose)

c      do i=1,ldimt
c         call avg1(disudtavg(1,1,1,1,i),disudt,alpha,beta,ntott,'dut '
c     &    ,ifverbose)
c         call avg1(disvdtavg(1,1,1,1,i),disvdt,alpha,beta,ntott,'dvt ',
c     &    ifverbose)
c         call avg1(diswdtavg(1,1,1,1,i),diswdt,alpha,beta,ntott,'dwt ',
c     &    ifverbose)
c         call avg1(distduavg(1,1,1,1,i),distdu,alpha,beta,ntott,'dtu ',
c     &    ifverbose)
c         call avg1(distdvavg(1,1,1,1,i),distdv,alpha,beta,ntott,'dtv ',
c     &    ifverbose)
c         call avg1(distdwavg(1,1,1,1,i),distdw,alpha,beta,ntott,'dtw ',
c     &    ifverbose)
c      enddo
      
      !Pressure scrambling term (velocity field)
            call avg3 (pdux,pr,dudx,alpha,beta,ntott,'pux ',ifverbose)
            call avg3 (pdvx,pr,dvdx,alpha,beta,ntott,'pvx ',ifverbose)
            call avg3 (pdwx,pr,dwdx,alpha,beta,ntott,'pwx ',ifverbose)
            call avg3 (pduy,pr,dudy,alpha,beta,ntott,'puy ',ifverbose)
            call avg3 (pdvy,pr,dvdy,alpha,beta,ntott,'pvy ',ifverbose)
            call avg3 (pdwy,pr,dwdy,alpha,beta,ntott,'pwy ',ifverbose)
            call avg3 (pduz,pr,dudz,alpha,beta,ntott,'puz ',ifverbose)
            call avg3 (pdvz,pr,dvdz,alpha,beta,ntott,'pvz ',ifverbose)
            call avg3 (pdwz,pr,dwdz,alpha,beta,ntott,'pwz ',ifverbose)
      !Viscous dissipation for scalar fields 
               do i = 1,ldimt
            call avg3 (udtdx(1,1,1,1,i),vx,dtdx(1,1,1,1,i),alpha,beta,
     &                 ntott,'utx ',ifverbose)

            call avg3 (vdtdx(1,1,1,1,i),vy,dtdx(1,1,1,1,i),alpha,beta,
     &                 ntott,'vtx ',ifverbose)

            call avg3 (udtdy(1,1,1,1,i),vx,dtdy(1,1,1,1,i),alpha,beta,
     &                 ntott,'uty ',ifverbose)

            call avg3 (vdtdy(1,1,1,1,i),vy,dtdy(1,1,1,1,i),alpha,beta,
     &                 ntott,'vty ',ifverbose)

            call avg3 (udtdz(1,1,1,1,i),vx,dtdz(1,1,1,1,i),alpha,beta,
     &                 ntott,'utz ',ifverbose)

            call avg3 (vdtdz(1,1,1,1,i),vy,dtdz(1,1,1,1,i),alpha,beta,
     &                 ntott,'vtz ',ifverbose)

            call avg3 (tdudx(1,1,1,1,i),t(1,1,1,1,i),dudx,alpha,beta,
     &                 ntott,'tux ',ifverbose)

            call avg3 (tdvdx(1,1,1,1,i),t(1,1,1,1,i),dvdx,alpha,beta,
     &                 ntott,'tvx ',ifverbose)

            call avg3 (tdudy(1,1,1,1,i),t(1,1,1,1,i),dudy,alpha,beta,
     &                 ntott,'tuy ',ifverbose)

            call avg3 (tdvdy(1,1,1,1,i),t(1,1,1,1,i),dvdy,alpha,beta,
     &                 ntott,'tvy ',ifverbose)

            call avg3 (tdudz(1,1,1,1,i),t(1,1,1,1,i),dudz,alpha,beta,
     &                 ntott,'tuz ',ifverbose)

            call avg3 (tdvdz(1,1,1,1,i),t(1,1,1,1,i),dvdz,alpha,beta,
     &                 ntott,'tvz ',ifverbose)


         enddo

         
c     }}}
c     Calculate integrals of dissipation
          idiss = glsc2(ss, bm1, ntot)
c     }}}
c     }}}
c     Calculate integrals of average velocity field
          avu = glsc2(vx, bm1, ntot)
          avv = glsc2(vy, bm1, ntot)
          avw = glsc2(vz, bm1, ntot)
c     }}}

         if (nid.eq.0) then
            write(6,1) istep,time,idiss,volvm1
            write(6,2) istep,time,avu/volvm1,avv/volvm1,avw/volvm1
    1       format(i9,1p3e16.8,' diss')
    2       format(i9,1p4e16.8,' avgt')
         endif

      endif
c
c-----------------------------------------------------------------------
      if ( (mod(istep,iastep).eq.0.and.istep.gt.1) .or.lastep.eq.1) then

         time_temp = time
         time      = atime   ! Output the duration of this avg
         dtmp      = param(63)
         param(63) = 1       ! Enforce 64-bit output
         
         !Averaged fields 
         call outpost2(uavg,vavg,wavg,pavg,tavg,ldimt,'avg')

         !Variance of fields 
         call outpost2(urms,vrms,wrms,prms,trms,ldimt,'rms')

         !Covariance of velocity field 
         call outpost (uvms,vwms,wums,bm1,bm1,      'rm2')

         !strain tensor 
         call outpost2(ssavg,ssavg,ssavg,ssavg,epsttavg,ldimt,'dis')
         
         !Pressure covariance 
         call outpost2(upms,vpms,wpms,upms,ptms,ldimt,'prs')
         call outpost2(pdux,pdvx,pdwx,pdux,pdtx,
     $                 ldimt,'pdx')
         call outpost2(pduy,pdvy,pdwy,pduy,pdty,
     $                 ldimt,'pdy')
         call outpost2(pduz,pdvz,pdwz,pduz,pdtz,
     $                 ldimt,'pdz')

         call outpost2(epsxxavg,epsxyavg,epsxzavg,epsxxavg,epstxavg,
     $                 ldimt,'exx')
         call outpost2(epsyyavg,epsxyavg,epsyzavg,epsyyavg,epstyavg,
     $                 ldimt,'eyy')
         call outpost2(epszzavg,epsyzavg,epsxzavg,epszzavg,epstzavg,
     $                 ldimt,'ezz')

         !Viscous diffusion terms for scalar fields 
         call outpost2(vx,vy,vz,pr,udtdx,ldimt,'utx')
         call outpost2(vx,vy,vz,pr,vdtdx,ldimt,'vtx')
         call outpost2(vx,vy,vz,pr,udtdy,ldimt,'uty')
         call outpost2(vx,vy,vz,pr,vdtdy,ldimt,'vty')
         call outpost2(vx,vy,vz,pr,udtdz,ldimt,'utz')
         call outpost2(vx,vy,vz,pr,vdtdz,ldimt,'vtz')

         call outpost2(vx,vy,vz,pr,tdudx,ldimt,'tux')
         call outpost2(vx,vy,vz,pr,tdvdx,ldimt,'tvx')
         call outpost2(vx,vy,vz,pr,tdudy,ldimt,'tuy')
         call outpost2(vx,vy,vz,pr,tdvdy,ldimt,'tvy')
         call outpost2(vx,vy,vz,pr,tdudz,ldimt,'tuz')
         call outpost2(vx,vy,vz,pr,tdvdz,ldimt,'tvz')

        
         !Turbulent diffusion terms 
         call outpost2(uuus,uuvs,uuws,uvws,uuts,ldimt,'tt1')
         call outpost2(vvvs,uvvs,vvws,uvws,vvts,ldimt,'tt2')
         call outpost2(wwws,uwws,vwws,uvws,wwts,ldimt,'tt3')
         call outpost2(uuus,uuvs,uuws,uvws,uvts,ldimt,'tt4')
         call outpost2(vvvs,uvvs,vvws,uvws,vwts,ldimt,'tt5')
         call outpost2(wwws,uwws,vwws,uvws,uwts,ldimt,'tt6')

         !Derivative of the mean values 
         call outpost2(uavgx,vavgx,wavgx,pavgx,tavgx,ldimt,'dax')
         call outpost2(uavgy,vavgy,wavgy,pavgy,tavgy,ldimt,'day')
         call outpost2(uavgz,vavgz,wavgz,pavgz,tavgz,ldimt,'daz')

         !Heat flux terms 
         call outpost2(uvms,vwms,wums,prms,tums,ldimt,'tu2')
         call outpost2(uvms,vwms,wums,prms,tvms,ldimt,'tv2')
         call outpost2(uvms,vwms,wums,prms,twms,ldimt,'tw2')

         param(63) = dtmp
         atime = 0.
         time  = time_temp  ! Restore clock

      endif
c
      timel = time
c
      return
      end
c-----------------------------------------------------------------------
      subroutine avg1(avg,f,alpha,beta,n,name,ifverbose)
      include 'SIZE'
      include 'TSTEP'
c
      real avg(n),f(n)
      character*4 name
      logical ifverbose
c
      do k=1,n
         avg(k) = alpha*avg(k) + beta*f(k)
      enddo
c
      if (ifverbose) then
         avgmax = glmax(avg,n)
         avgmin = glmin(avg,n)
         if (nio.eq.0) write(6,1) istep,time,avgmin,avgmax
     $                           ,alpha,beta,name
    1    format(i9,1p5e13.5,1x,a4,' av1mnx')
      endif
c
      return
      end
c-----------------------------------------------------------------------
      subroutine avg2(avg,f,alpha,beta,n,name,ifverbose)
      include 'SIZE'
      include 'TSTEP'
c
      real avg(n),f(n)
      character*4 name
      logical ifverbose
c
      do k=1,n
         avg(k) = alpha*avg(k) + beta*f(k)*f(k)
      enddo
c
      if (ifverbose) then
         avgmax = glmax(avg,n)
         avgmin = glmin(avg,n)
         if (nio.eq.0) write(6,1) istep,time,avgmin,avgmax
     $                           ,alpha,beta,name
    1    format(i9,1p5e13.5,1x,a4,' av2mnx')
      endif
c
      return
      end
c-----------------------------------------------------------------------
      subroutine my_avg3(avg,f,g,alpha,beta,n,name,ifverbose)
      include 'SIZE'
      include 'TSTEP'
c
      real avg(n),f(n),g(n)
      character*4 name
      logical ifverbose
c
      do k=1,n
         avg(k) = alpha*avg(k) + beta*f(k)*g(k)
      enddo
c
      if (ifverbose) then
         avgmax = glmax(avg,n)
         avgmin = glmin(avg,n)
         if (nio.eq.0) write(6,1) istep,time,avgmin,avgmax
     $                           ,alpha,beta,name
    1    format(i9,1p5e13.5,1x,a4,' av3mnx')
      endif
c
      return
      end
c-----------------------------------------------------------------------
      subroutine avg4(avg, f, g, h, alpha, beta, n, name, ifverbose)
      include 'SIZE'
      include 'TSTEP'
c
      real avg(n), f(n), g(n), h(n)
      character*4 name
      logical ifverbose
c
      do k = 1, n
         avg(k) = alpha * avg(k) + beta * f(k) * g(k) * h(k)
      enddo
c
      if (ifverbose) then
         avgmax = glmax(avg, n)
         avgmin = glmin(avg, n)
         if (nio.eq.0) write(6, 1) istep, time, avgmin, avgmax, alpha, 
     &                             beta, name
    1    format(i9, 1p5e13.5, 1x, a4, ' av4mnx')
      endif
c
      return
      end
c-----------------------------------------------------------------------

      subroutine my_mag_tensor_e(mag,aije)
c
c     Compute magnitude of tensor A_e for element e
c
c     mag(A_e) = 0.5 (A:A)
c
      include 'SIZE'
      REAL mag (lx1*ly1*lz1)
      REAL aije(lx1*ly1*lz1,ldim,ldim)
      
      nxyz = lx1*ly1*lz1
      
      call rzero(mag,nxyz)
       
      do 100 j=1,ldim
      do 100 i=1,ldim
      do 100 l=1,nxyz 
            mag(l) = mag(l) + 0.5*aije(l,i,j)*aije(l,i,j)
 100  continue
      
      return
      end      

c-----------------------------------------------------------------------
      real function p_outflow(ix,iy,iz,iel,iside,u0,delta)

      include 'SIZE'
      include 'SOLN'
      include 'GEOM'
      common /myblas/ ub(lx1,ly1,lz1,lelt),vb(lx1,ly1,lz1,lelt)

      real sn(3)

      real dudx(lx1, ly1, lz1, lelt)
      real dudy(lx1, ly1, lz1, lelt)
      real dudz(lx1, ly1, lz1, lelt)
      real dvdx(lx1, ly1, lz1, lelt)
      real dvdy(lx1, ly1, lz1, lelt)
      real dvdz(lx1, ly1, lz1, lelt)
      real dwdx(lx1, ly1, lz1, lelt)
      real dwdy(lx1, ly1, lz1, lelt)
      real dwdz(lx1, ly1, lz1, lelt)


      nu = vdiff(ix,iy,iz,iel,1)

      ! Compute the gradients 
      call gradm1(dudx, dudy, dudz, vx)
      call gradm1(dvdx, dvdy, dvdz, vy)
      call gradm1(dwdx, dwdy, dwdz, vz)
      ux = vx(ix,iy,iz,iel)
      uy = vy(ix,iy,iz,iel)
      uz = vz(ix,iy,iz,iel) 
      ! Ensure gradients are scalars
      dux = dudx(ix,iy,iz,iel)
      duy = dudy(ix,iy,iz,iel)
      duz = dudz(ix,iy,iz,iel)
      dvx = dvdx(ix,iy,iz,iel)
      dvy = dvdy(ix,iy,iz,iel)
      dvz = dvdz(ix,iy,iz,iel)
      dwx = dwdx(ix,iy,iz,iel)
      dwy = dwdy(ix,iy,iz,iel)
      dwz = dwdz(ix,iy,iz,iel)

      call getSnormal(sn,ix,iy,iz,iside,iel)
      vn = ux*sn(1) + uy*sn(2) + uz*sn(3)
      S0 = 0.5*(1.0 - tanh(vn/u0/delta))

      ! viscous term
      dun = dux*sn(1) + duy*sn(2) + duz*sn(3)
      dvn = dvx*sn(1) + dvy*sn(2) + dvz*sn(3)
      dwn = dwx*sn(1) + dwy*sn(2) + dwz*sn(3)
      dn = sn(1)*dun + sn(2)*dvn + sn(3)*dwn 
      visc_term = nu*dn 

      p_outflow = -0.5*(ux*ux+uy*uy+uz*uz)*S0+ visc_term 

      
      return
      end












!======================================================================
      subroutine frame_usr_register
      implicit none
      include 'SIZE'
      include 'FRAMELP'
!-----------------------------------------------------------------------
!     register modules
      call io_register
      call chkpt_register
      call trip_register
! 	   call spng_register
      return
      end subroutine
!======================================================================
      subroutine frame_usr_init
      implicit none
      include 'SIZE'
      include 'FRAMELP'
      include 'SOLN'

      ! local variables
      integer nn

!      real vtmp(lx1*ly1*lz1*lelt,ldim)
!      common /ctmp1/ vtmp
!-----------------------------------------------------------------------
!     initialise modules
      call chkpt_init
      call trip_init
!      nn = lx1*ly1*lz1*lelt*ldim 
!      call rzero(vtmp,nn)
!      call spng_init(vtmp(1,1),vtmp(1,2),vtmp(1,ndim))

      return
      end subroutine
!======================================================================
      subroutine frame_usr_end
      implicit none
      include 'SIZE'
      include 'FRAMELP'
!-----------------------------------------------------------------------
!     finalise modules
      
      return
      end subroutine
!======================================================================

      subroutine trip_register()
      implicit none

      include 'SIZE'
      include 'INPUT'
      include 'FRAMELP'
      include 'TRIPD'

      ! local variables
      integer lpmid, il
      real ltim
      character*2 str

      ! functions
      real dnekclock
!-----------------------------------------------------------------------
      ! timing
      ltim = dnekclock()

      ! check if the current module was already registered
      call mntr_mod_is_name_reg(lpmid,trip_name)
      if (lpmid.gt.0) then
         call mntr_warn(lpmid,
     $        'module ['//trim(trip_name)//'] already registered')
         return
      endif

      ! find parent module
      call mntr_mod_is_name_reg(lpmid,'FRAME')
      if (lpmid.le.0) then
         lpmid = 1
         call mntr_abort(lpmid,
     $        'parent module ['//'FRAME'//'] not registered')
      endif

      ! register module
      call mntr_mod_reg(trip_id,lpmid,trip_name,
     $      'Tripping along the line')

      ! register timer
      call mntr_tmr_is_name_reg(lpmid,'FRM_TOT')
      call mntr_tmr_reg(trip_tmr_id,lpmid,trip_id,
     $     'TRIP_TOT','Tripping total time',.false.)

      ! register and set active section
      call rprm_sec_reg(trip_sec_id,trip_id,'_'//adjustl(trip_name),
     $     'Runtime paramere section for tripping module')
      call rprm_sec_set_act(.true.,trip_sec_id)

      ! register parameters
      call rprm_rp_reg(trip_nline_id,trip_sec_id,'NLINE',
     $     'Number of tripping lines',rpar_int,0,0.0,.false.,' ')

      call rprm_rp_reg(trip_tiamp_id,trip_sec_id,'TIAMP',
     $     'Time independent amplitude',rpar_real,0,0.0,.false.,' ')

      call rprm_rp_reg(trip_tdamp_id,trip_sec_id,'TDAMP',
     $     'Time dependent amplitude',rpar_real,0,0.0,.false.,' ')

      do il=1, trip_nline_max
         write(str,'(I2.2)') il

         call rprm_rp_reg(trip_spos_id(1,il),trip_sec_id,'SPOSX'//str,
     $     'Starting point X',rpar_real,0,0.0,.false.,' ')
         
         call rprm_rp_reg(trip_spos_id(2,il),trip_sec_id,'SPOSY'//str,
     $     'Starting point Y',rpar_real,0,0.0,.false.,' ')

         if (IF3D) then
            call rprm_rp_reg(trip_spos_id(ldim,il),trip_sec_id,
     $           'SPOSZ'//str,'Starting point Z',
     $           rpar_real,0,0.0,.false.,' ')
         endif
        
         call rprm_rp_reg(trip_epos_id(1,il),trip_sec_id,'EPOSX'//str,
     $     'Ending point X',rpar_real,0,0.0,.false.,' ')
         
         call rprm_rp_reg(trip_epos_id(2,il),trip_sec_id,'EPOSY'//str,
     $     'Ending point Y',rpar_real,0,0.0,.false.,' ')

         if (IF3D) then
            call rprm_rp_reg(trip_epos_id(ldim,il),trip_sec_id,
     $           'EPOSZ'//str,'Ending point Z',
     $           rpar_real,0,0.0,.false.,' ')
         endif

         call rprm_rp_reg(trip_smth_id(1,il),trip_sec_id,'SMTHX'//str,
     $     'Smoothing length X',rpar_real,0,0.0,.false.,' ')
         
         call rprm_rp_reg(trip_smth_id(2,il),trip_sec_id,'SMTHY'//str,
     $     'Smoothing length Y',rpar_real,0,0.0,.false.,' ')

         if (IF3D) then
            call rprm_rp_reg(trip_smth_id(ldim,il),trip_sec_id,
     $           'SMTHZ'//str,'Smoothing length Z',
     $           rpar_real,0,0.0,.false.,' ')
         endif
      
         call rprm_rp_reg(trip_rota_id(il),trip_sec_id,'ROTA'//str,
     $        'Rotation angle',rpar_real,0,0.0,.false.,' ')
         call rprm_rp_reg(trip_nmode_id(il),trip_sec_id,'NMODE'//str,
     $     'Number of Fourier modes',rpar_int,0,0.0,.false.,' ')
         call rprm_rp_reg(trip_tdt_id(il),trip_sec_id,'TDT'//str,
     $     'Time step for tripping',rpar_real,0,0.0,.false.,' ')
      enddo

      ! set initialisation flag
      trip_ifinit=.false.
      
      ! timing
      ltim = dnekclock() - ltim
      call mntr_tmr_add(trip_tmr_id,1,ltim)

      return
      end subroutine
!=======================================================================
!> @brief Initilise tripping module
!! @ingroup trip_line
!! @note This routine should be called in frame_usr_init
      subroutine trip_init()
      implicit none

      include 'SIZE'
      include 'INPUT'
      include 'GEOM'
      include 'FRAMELP'
      include 'TRIPD'

      ! local variables
      integer itmp
      real rtmp, ltim
      logical ltmp
      character*20 ctmp

      integer il, jl

      ! functions
      real dnekclock
!-----------------------------------------------------------------------
      ! check if the module was already initialised
      if (trip_ifinit) then
         call mntr_warn(trip_id,
     $        'module ['//trim(trip_name)//'] already initiaised.')
         return
      endif
      
      ! timing
      ltim = dnekclock()

      ! get runtime parameters
      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,trip_nline_id,rpar_int)
      trip_nline = itmp
      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,trip_tiamp_id,rpar_real)
      trip_tiamp = rtmp
      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,trip_tdamp_id,rpar_real)
      trip_tdamp = rtmp
      do il=1,trip_nline
         do jl=1,LDIM
            call rprm_rp_get(itmp,rtmp,ltmp,ctmp,trip_spos_id(jl,il),
     $           rpar_real)
            trip_spos(jl,il) = rtmp
            call rprm_rp_get(itmp,rtmp,ltmp,ctmp,trip_epos_id(jl,il),
     $           rpar_real)
            trip_epos(jl,il) = rtmp
            call rprm_rp_get(itmp,rtmp,ltmp,ctmp,trip_smth_id(jl,il),
     $           rpar_real)
            trip_smth(jl,il) = rtmp
         enddo
         call rprm_rp_get(itmp,rtmp,ltmp,ctmp,trip_rota_id(il),
     $        rpar_real)
         trip_rota(il) = rtmp
         call rprm_rp_get(itmp,rtmp,ltmp,ctmp,trip_nmode_id(il),
     $        rpar_int)
         trip_nmode(il) = itmp
         call rprm_rp_get(itmp,rtmp,ltmp,ctmp,trip_tdt_id(il),
     $        rpar_real)
         trip_tdt(il) = rtmp
      enddo

      ! get inverse line lengths and smoothing radius
      do il=1,trip_nline
         trip_ilngt(il) = 0.0
         do jl=1,LDIM
            trip_ilngt(il) = trip_ilngt(il) + (trip_epos(jl,il)-
     $           trip_spos(jl,il))**2
         enddo
         if (trip_ilngt(il).gt.0.0) then
            trip_ilngt(il) = 1.0/sqrt(trip_ilngt(il))
         else
            trip_ilngt(il) = 1.0
         endif
         do jl=1,LDIM
            if (trip_smth(jl,il).gt.0.0) then
               trip_ismth(jl,il) = 1.0/trip_smth(jl,il)
            else
               trip_ismth(jl,il) = 1.0
            endif
         enddo
      enddo

      ! get 1D projection and array mapping
      call trip_1dprj

      ! initialise random generator seed and number of time intervals
      do il=1,trip_nline
         trip_seed(il) = -32*il
      enddo
      trip_ntdt = 1 - trip_nset_max
      trip_ntdt_old = trip_ntdt
      
      ! generate random phases (time independent and time dependent)
      call trip_rphs_get

      ! get forcing
      call trip_frcs_get(.true.)
      
      ! everything is initialised
      trip_ifinit=.true.

      ! timing
      ltim = dnekclock() - ltim
      call mntr_tmr_add(trip_tmr_id,1,ltim)

      return
      end subroutine
!=======================================================================
!> @brief Check if module was initialised
!! @ingroup trip_line
!! @return trip_is_initialised
      logical function trip_is_initialised()
      implicit none

      include 'SIZE'
      include 'TRIPD'
!-----------------------------------------------------------------------
      trip_is_initialised = trip_ifinit

      return
      end function
!=======================================================================
!> @brief Update tripping
!! @ingroup trip_line
      subroutine trip_update()
      implicit none

      include 'SIZE'
      include 'TRIPD'

      ! local variables
      real ltim
      
      ! functions
      real dnekclock
!-----------------------------------------------------------------------
      ! timing
      ltim = dnekclock()      

      ! update random phases (time independent and time dependent)
      call trip_rphs_get

      ! update forcing
      call trip_frcs_get(.false.)

      ! timing
      ltim = dnekclock() - ltim
      call mntr_tmr_add(trip_tmr_id,1,ltim)

      return
      end subroutine      
!=======================================================================
!> @brief Compute tripping forcing
!! @ingroup trip_line
!! @param[inout] ffx,ffy,ffz     forcing; x,y,z component
!! @param[in]    ix,iy,iz        GLL point index
!! @param[in]    ieg             global element number
      subroutine trip_forcing(ffx,ffy,ffz,ix,iy,iz,ieg)
      implicit none

      include 'SIZE'
      include 'PARALLEL'
      include 'TRIPD'

      ! argument list
      real ffx, ffy, ffz
      integer ix,iy,iz,ieg

      ! local variables
      integer ipos,iel,il
      real ffn
!-----------------------------------------------------------------------
      iel=GLLEL(ieg)
      ffn = 0.0
      
      do il= 1, trip_nline
         ipos = trip_map(ix,iy,iz,iel,il)
         ffn = trip_ftrp(ipos,il)*trip_fsmth(ix,iy,iz,iel,il)
         
         ffx = ffx - ffn*sin(trip_rota(il))
         ffy = ffy + ffn*cos(trip_rota(il))
      enddo
      
      return
      end subroutine
!=======================================================================
!> @brief Reset tripping
!! @ingroup trip_line
      subroutine trip_reset()
      implicit none

      include 'SIZE'
      include 'TRIPD'

      ! local variables
      real ltim
      
      ! functions
      real dnekclock
!-----------------------------------------------------------------------
      ! timing
      ltim = dnekclock()      

      ! get 1D projection and array mapping
      call trip_1dprj
      
      ! update forcing
      call trip_frcs_get(.true.)

      ! timing
      ltim = dnekclock() - ltim
      call mntr_tmr_add(trip_tmr_id,1,ltim)

      return
      end subroutine
!=======================================================================
!> @brief Get 1D projection, array mapping and forcing smoothing
!! @ingroup trip_line
!! @details This routine is just a simple version supporting only lines
!!   paralles to z axis. In future it can be generalised.
!! @remark This routine uses global scratch space \a CTMP0 and \a CTMP1
      subroutine trip_1dprj()
      implicit none

      include 'SIZE'
      include 'INPUT'
      include 'GEOM'
      include 'TRIPD'

      ! local variables
      integer npxy, npel, nptot, itmp, jtmp, ktmp, eltmp
      integer il, jl
      real xl, yl, xr, yr, rota, rtmp, epsl
      parameter (epsl = 1.0e-10)
      
      real lcoord(LX1*LY1*LZ1*LELT)
      common /CTMP0/ lcoord
      integer lmap(LX1*LY1*LZ1*LELT)
      common /CTMP1/ lmap
!-----------------------------------------------------------------------
      npxy = NX1*NY1
      npel = npxy*NZ1
      nptot = npel*NELV
      
      ! for each line
      do il=1,trip_nline
      ! Get coordinates and sort them
         call copy(lcoord,zm1,nptot)
         call sort(lcoord,lmap,nptot)

         ! find unique entrances and provide mapping
         trip_npoint(il) = 1
         trip_prj(trip_npoint(il),il) = lcoord(1)
         itmp = lmap(1)-1
         eltmp = itmp/npel + 1
         itmp = itmp - npel*(eltmp-1)
         ktmp = itmp/npxy + 1
         itmp = itmp - npxy*(ktmp-1)
         jtmp = itmp/nx1 + 1
         itmp = itmp - nx1*(jtmp-1) + 1
         trip_map(itmp,jtmp,ktmp,eltmp,il) = trip_npoint(il)
         do jl=2,nptot
            if((lcoord(jl)-trip_prj(trip_npoint(il),il)).gt.
     $           max(epsl,abs(epsl*lcoord(jl)))) then
               trip_npoint(il) = trip_npoint(il) + 1
               trip_prj(trip_npoint(il),il) = lcoord(jl)
            endif

            itmp = lmap(jl)-1
            eltmp = itmp/npel + 1
            itmp = itmp - npel*(eltmp-1)
            ktmp = itmp/npxy + 1
            itmp = itmp - npxy*(ktmp-1)
            jtmp = itmp/nx1 + 1
            itmp = itmp - nx1*(jtmp-1) + 1
            trip_map(itmp,jtmp,ktmp,eltmp,il) = trip_npoint(il)
         enddo
             
         ! rescale 1D array
         do jl=1,trip_npoint(il)
            trip_prj(jl,il) = (trip_prj(jl,il) - trip_spos(ldim,il))
     $           *trip_ilngt(il)
         enddo
         
         ! get smoothing profile
         rota = trip_rota(il)
         
         do jl=1,nptot
            itmp = jl-1
            eltmp = itmp/npel + 1
            itmp = itmp - npel*(eltmp-1)
            ktmp = itmp/npxy + 1
            itmp = itmp - npxy*(ktmp-1)
            jtmp = itmp/nx1 + 1
            itmp = itmp - nx1*(jtmp-1) + 1

            ! rotation
            xl = xm1(itmp,jtmp,ktmp,eltmp)-trip_spos(1,il)
            yl = ym1(itmp,jtmp,ktmp,eltmp)-trip_spos(2,il)

            xr = xl*cos(rota)+yl*sin(rota)
            yr = -xl*sin(rota)+yl*cos(rota)
            
            rtmp = (xr*trip_ismth(1,il))**2 + (yr*trip_ismth(2,il))**2
            ! Gauss
            !trip_fsmth(itmp,jtmp,ktmp,eltmp,il) = exp(-4.0*rtmp)
            ! limited support
            if (rtmp.lt.1.0) then
               trip_fsmth(itmp,jtmp,ktmp,eltmp,il) =
     $              exp(-rtmp)*(1-rtmp)**2
            else
               trip_fsmth(itmp,jtmp,ktmp,eltmp,il) = 0.0
            endif

         enddo
      enddo

      return
      end subroutine      
!=======================================================================
!> @brief Generate set of random phases
!! @ingroup trip_line
      subroutine trip_rphs_get
      implicit none

      include 'SIZE'
      include 'TSTEP'
      include 'PARALLEL'
      include 'TRIPD'
      
      ! local variables
      integer il, jl, kl
      integer itmp
      real trip_ran2

#ifdef DEBUG
      character*3 str1, str2
      integer iunit, ierr
      ! call number
      integer icalldl
      save icalldl
      data icalldl /0/
#endif
!-----------------------------------------------------------------------
      ! time independent part
      if (trip_tiamp.gt.0.0.and..not.trip_ifinit) then
         do il = 1, trip_nline
            do jl=1, trip_nmode(il)
               trip_rphs(jl,1,il) = 2.0*pi*trip_ran2(il)
            enddo
         enddo
      endif

      ! time dependent part
      do il = 1, trip_nline
         itmp = int(time/trip_tdt(il))
         call bcast(itmp,ISIZE) ! just for safety
         do kl= trip_ntdt+1, itmp
            do jl= trip_nset_max,3,-1
               call copy(trip_rphs(1,jl,il),trip_rphs(1,jl-1,il),
     $              trip_nmode(il))
            enddo
            do jl=1, trip_nmode(il)
               trip_rphs(jl,2,il) = 2.0*pi*trip_ran2(il)
            enddo
         enddo
      enddo
      
      ! update time interval
      trip_ntdt_old = trip_ntdt
      trip_ntdt = itmp

#ifdef DEBUG
      ! for testing
      ! to output refinement
      icalldl = icalldl+1
      call io_file_freeid(iunit, ierr)
      write(str1,'(i3.3)') NID
      write(str2,'(i3.3)') icalldl
      open(unit=iunit,file='trp_rps.txt'//str1//'i'//str2)

      do il=1,trip_nmode(1)
         write(iunit,*) il,trip_rphs(il,1:4,1)
      enddo

      close(iunit)
#endif

      return
      end subroutine
!=======================================================================
!> @brief A simple portable random number generator
!! @ingroup trip_line
!! @details  Requires 32-bit integer arithmetic. Taken from Numerical
!!   Recipes, William Press et al. Gives correlation free random
!!   numbers but does not have a very large dynamic range, i.e only
!!   generates 714025 different numbers. Set seed negative for
!!   initialization
!! @param[in]   il      line number
!! @return      ran
      real function trip_ran2(il)
      implicit none

      include 'SIZE'
      include 'TRIPD'
      
      ! argument list
      integer il

      ! local variables
      integer iff(trip_nline_max), iy(trip_nline_max)
      integer ir(97,trip_nline_max)
      integer m,ia,ic,j
      real rm
      parameter (m=714025,ia=1366,ic=150889,rm=1./m)
      save iff,ir,iy
      data iff /trip_nline_max*0/
!-----------------------------------------------------------------------
      ! initialise
      if (trip_seed(il).lt.0.or.iff(il).eq.0) then
         iff(il)=1
         trip_seed(il)=mod(ic-trip_seed(il),m)
         do j=1,97
            trip_seed(il)=mod(ia*trip_seed(il)+ic,m)
            ir(j,il)=trip_seed(il)
         end do
         trip_seed(il)=mod(ia*trip_seed(il)+ic,m)
         iy(il)=trip_seed(il)
      end if
      
      ! generate random number
      j=1+(97*iy(il))/m
      iy(il)=ir(j,il)
      trip_ran2=iy(il)*rm
      trip_seed(il)=mod(ia*trip_seed(il)+ic,m)
      ir(j,il)=trip_seed(il)

      end function
!=======================================================================
!> @brief Generate forcing along 1D line
!! @ingroup trip_line
!! @param[in] ifreset    reset flag
      subroutine trip_frcs_get(ifreset)
      implicit none

      include 'SIZE'
      include 'INPUT'
      include 'TSTEP'
      include 'TRIPD'

      ! argument list
      logical ifreset

#ifdef TRIP_PR_RST
      ! variables necessary to reset pressure projection for P_n-P_n-2
      integer nprv(2)
      common /orthbi/ nprv

      ! variables necessary to reset velocity projection for P_n-P_n-2
      include 'VPROJ'
#endif      
      ! local variables
      integer il, jl, kl, ll
      integer istart
      real theta0, theta

#ifdef DEBUG
      character*3 str1, str2
      integer iunit, ierr
      ! call number
      integer icalldl
      save icalldl
      data icalldl /0/
#endif
!-----------------------------------------------------------------------
      ! reset all
      if (ifreset) then
         if (trip_tiamp.gt.0.0) then
            istart = 1
         else
            istart = 2
         endif
         do il= 1, trip_nline
            do jl = istart, trip_nset_max
               call rzero(trip_frcs(1,jl,il),trip_npoint(il))
               do kl= 1, trip_npoint(il)
                  theta0 = 2*pi*trip_prj(kl,il)
                  do ll= 1, trip_nmode(il)
                     theta = theta0*ll
                     trip_frcs(kl,jl,il) = trip_frcs(kl,jl,il) +
     $                    sin(theta+trip_rphs(ll,jl,il))
                  enddo
               enddo
            enddo
         enddo
         ! rescale time independent part
         if (trip_tiamp.gt.0.0) then
            do il= 1, trip_nline
               call cmult(trip_frcs(1,1,il),trip_tiamp,trip_npoint(il))
            enddo
         endif
      else
         ! reset only time dependent part if needed
         if (trip_ntdt.ne.trip_ntdt_old) then
#ifdef TRIP_PR_RST
            ! reset projection space
            ! pressure
            if (int(PARAM(95)).gt.0) then
               PARAM(95) = ISTEP
               nprv(1) = 0      ! veloctiy field only
            endif
            ! velocity
            if (int(PARAM(94)).gt.0) then
               PARAM(94) = ISTEP!+2
               ivproj(2,1) = 0
               ivproj(2,2) = 0
               if (IF3D) ivproj(2,3) = 0
            endif
#endif
            do il= 1, trip_nline
               do jl= trip_nset_max,3,-1
                  call copy(trip_frcs(1,jl,il),trip_frcs(1,jl-1,il),
     $                 trip_npoint(il))
               enddo
               call rzero(trip_frcs(1,2,il),trip_npoint(il))
               do jl= 1, trip_npoint(il)
                  theta0 = 2*pi*trip_prj(jl,il)
                  do kl= 1, trip_nmode(il)
                     theta = theta0*kl
                     trip_frcs(jl,2,il) = trip_frcs(jl,2,il) +
     $                    sin(theta+trip_rphs(kl,2,il))
                  enddo
               enddo
            enddo
         endif
      endif
      
      ! get tripping for current time step
      if (trip_tiamp.gt.0.0) then
         do il= 1, trip_nline
           call copy(trip_ftrp(1,il),trip_frcs(1,1,il),trip_npoint(il))
         enddo
      else
         do il= 1, trip_nline
            call rzero(trip_ftrp(1,il),trip_npoint(il))
         enddo
      endif
      ! interpolation in time
      do il = 1, trip_nline
         theta0= time/trip_tdt(il)-real(trip_ntdt)
         if (theta0.gt.0.0) then
            theta0=theta0*theta0*(3.0-2.0*theta0)
            !theta0=theta0*theta0*theta0*(10.0+(6.0*theta0-15.0)*theta0)
            do jl= 1, trip_npoint(il)
               trip_ftrp(jl,il) = trip_ftrp(jl,il) +
     $              trip_tdamp*((1.0-theta0)*trip_frcs(jl,3,il) +
     $              theta0*trip_frcs(jl,2,il))
            enddo
         else
            theta0=theta0+1.0
            theta0=theta0*theta0*(3.0-2.0*theta0)
            !theta0=theta0*theta0*theta0*(10.0+(6.0*theta0-15.0)*theta0)
            do jl= 1, trip_npoint(il)
               trip_ftrp(jl,il) = trip_ftrp(jl,il) +
     $              trip_tdamp*((1.0-theta0)*trip_frcs(jl,4,il) +
     $              theta0*trip_frcs(jl,3,il))
            enddo
         endif
      enddo

#ifdef DEBUG
      ! for testing
      ! to output refinement
      icalldl = icalldl+1
      call io_file_freeid(iunit, ierr)
      write(str1,'(i3.3)') NID
      write(str2,'(i3.3)') icalldl
      open(unit=iunit,file='trp_fcr.txt'//str1//'i'//str2)

      do il=1,trip_npoint(1)
         write(iunit,*) il,trip_prj(il,1),trip_ftrp(il,1),
     $        trip_frcs(il,1:4,1)
      enddo

      close(iunit)
#endif
      
      return
      end subroutine
!=======================================================================

!> @file rprm_block.f
!! @ingroup runparam
!! @brief Block data to initialise common block for runtime parameter module
!! @details Following Nek5000 standard I keep block data in seaprate file.
!! @author Adam Peplinski
!! @date Sep 28, 2017
!=======================================================================
      block data rprm_common_init
      include 'RPRMD'

      data rprm_ifinit /.false./
      data rprm_pid0 /0/
      data rprm_sec_num /0/
      data rprm_sec_mpos /0/
      data rprm_sec_id /rprm_sec_id_max*-1/
      data rprm_sec_act /rprm_sec_id_max*.false./
      data rprm_sec_name /rprm_sec_id_max*rprm_blname/
      data rprm_par_num /0/
      data rprm_par_mpos /0/
      data rprm_par_id /rprm_par_id_size*-1/
      data rprm_par_name /rprm_par_id_max*rprm_blname/
      data rprm_parv_int /rprm_par_id_max*0/
      data rprm_parv_real /rprm_par_id_max*0.0/
      data rprm_parv_log /rprm_par_id_max*.false./
      data rprm_parv_str /rprm_par_id_max*rprm_blname/

      end


!> @file rprm.f
!! @ingroup runparam
!! @brief Set of subroutines related to module's runtime parameters.
!! @author Adam Peplinski
!! @date Feb 5, 2017
!=======================================================================
!> @brief Register runtime parameters database
!! @ingroup runparam
      subroutine rprm_register
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'RPRMD'

      ! local variables
      integer itmp

      ! functions
      integer frame_get_master
!-----------------------------------------------------------------------
      rprm_pid0 = frame_get_master()

      ! check if the current module was already registered
      call mntr_mod_is_name_reg(itmp,rprm_name)
      if (itmp.gt.0) then
         call mntr_warn(itmp,
     $        'module ['//trim(rprm_name)//'] already registered')
         return
      endif

      ! find parent module
      call mntr_mod_is_name_reg(itmp,'FRAME')
      if (itmp.le.0) then
         itmp = 1
         call mntr_abort(itmp,
     $        'parent module ['//'FRAME'//'] not registered')
      endif

      ! register module
      call mntr_mod_reg(rprm_id,itmp,rprm_name,'Runtime parameters')

      ! register and set active section
      call rprm_sec_reg(rprm_lsec_id,rprm_id,'_'//adjustl(rprm_name),
     $     'Runtime parameter section for rprm module')
      call rprm_sec_set_act(.true.,rprm_lsec_id)

      ! register parameters
      call rprm_rp_reg(rprm_ifparf_id,rprm_lsec_id,'PARFWRITE',
     $     'Do we write runtime parameter file',rpar_log,0,
     $      0.0,.false.,' ')

      call rprm_rp_reg(rprm_parfnm_id,rprm_lsec_id,'PARFNAME',
     $   'Runtime parameter file name for output (without .par)',
     $   rpar_str,0,0.0,.false.,'outparfile')

      return
      end subroutine
!=======================================================================
!> @brief Initialise modules runtime parameters and write summary
!! @ingroup runparam
      subroutine rprm_init
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'RPRMD'

      ! local variables
      integer itmp
      real rtmp
      logical ltmp
      character*20 ctmp
      integer iunit, ierr
      character*30 fname
!-----------------------------------------------------------------------
      ! check if the module was already initialised
      if (rprm_ifinit) then
         call mntr_warn(rprm_id,
     $        'module ['//trim(rprm_name)//'] already initiaised.')
         return
      endif

      ! get runtime parameters
      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,rprm_ifparf_id,rpar_log)
      rprm_ifparf = ltmp
      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,rprm_parfnm_id,rpar_str)
      rprm_parfnm = ctmp

      ! write summary
      iunit = 6
      call rprm_rp_summary_print(iunit)

      ! save .par file
      if (rprm_ifparf) then
         call io_file_freeid(iunit, ierr)
         if (ierr.eq.0) then
           fname=trim(adjustl(rprm_parfnm))//'.par'
           open(unit=iunit,file=fname,status='new',iostat=ierr)
           if (ierr.eq.0) then
             call rprm_rp_summary_print(iunit)
             close (iunit)
           else
             call mntr_log(rprm_id,lp_inf,
     $        'ERROR: cannot open output .par file')
           endif
         else
           call mntr_log(rprm_id,lp_inf,
     $        'ERROR: cannot allocate iunit for output .par file')
         endif
      endif

      ! everything is initialised
      rprm_ifinit = .true.

      return
      end subroutine
!=======================================================================
!> @brief Check if module was initialised
!! @ingroup runparam
!! @return rprm_is_initialised
      logical function rprm_is_initialised()
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'RPRMD'
!-----------------------------------------------------------------------
      rprm_is_initialised = rprm_ifinit

      return
      end function
!=======================================================================
!> @brief Register new parameter section
!! @ingroup runparam
!! @param[out] rpid     current section id
!! @param[in]  mid      registering module id
!! @param[in]  pname    section name
!! @param[in]  pdscr    section description
      subroutine rprm_sec_reg(rpid,mid,pname,pdscr)
      implicit none

      include 'SIZE'
      include 'PARALLEL'        ! ISIZE
      include 'FRAMELP'
      include 'RPRMD'

      ! argument list
      integer rpid, mid
      character*(*) pname, pdscr

      ! local variables
      character*10  mname
      character*20  lname
      character*132 ldscr
      character*200 llog
      integer slen,slena

      integer il, ipos
      integer lval

      ! functions
      logical mntr_mod_is_id_reg
!-----------------------------------------------------------------------
      ! check name length
      slena = len_trim(adjustl(pname))
      ! remove trailing blanks
      slen = len_trim(pname) - slena + 1
      if (slena.gt.rprm_lstl_mnm) then
         call mntr_log(rprm_id,lp_deb,
     $        'too long section name; shortenning')
         slena = min(slena,rprm_lstl_mnm)
      endif
      call blank(lname,rprm_lstl_mnm)
      lname= pname(slen:slen+slena- 1)
      call capit(lname,slena)

      ! check description length
      slena = len_trim(adjustl(pdscr))
      ! remove trailing blanks
      slen = len_trim(pdscr) - slena + 1
      if (slena.ge.rprm_lstl_mds) then
         call mntr_log(rprm_id,lp_deb,
     $        'too long section description; shortenning')
         slena = min(slena,rprm_lstl_mnm)
      endif
      call blank(ldscr,rprm_lstl_mds)
      ldscr= pdscr(slen:slen + slena - 1)

      ! find empty space
      ipos = 0

      ! to ensure consistency I do it on master and broadcast result
      if (nid.eq.rprm_pid0) then

         ! check if parameter name is already registered
         do il=1,rprm_sec_mpos
            if (rprm_sec_id(il).gt.0.and.
     $          rprm_sec_name(il).eq.lname) then
               ipos = -il
               exit
            endif
         enddo

         ! find empty spot
         if (ipos.eq.0) then
            do il=1,rprm_sec_id_max
               if (rprm_sec_id(il).eq.-1) then
                  ipos = il
                  exit
               endif
            enddo
         endif
      endif

      ! broadcast ipos
      call bcast(ipos,isize)

      ! error; no free space found
      if (ipos.eq.0) then
         rpid = ipos
         call mntr_abort(rprm_id,
     $        'Section '//trim(lname)//' cannot be registered')
      ! section already registered
      elseif (ipos.lt.0) then
         rpid = abs(ipos)
         call mntr_abort(rprm_id,
     $    'Section '//trim(lname)//' is already registered')
      ! new section
      else
         rpid = ipos
         ! check if module is registered
         if (mntr_mod_is_id_reg(mid)) then
            rprm_sec_id(ipos) = mid
         else
            call mntr_abort(rprm_id,
     $          "Sections's "//trim(lname)//" module not registered")
         endif
         rprm_sec_name(ipos)=lname
         rprm_sec_dscr(ipos)=ldscr
         rprm_sec_num = rprm_sec_num + 1
         if (rprm_sec_mpos.lt.ipos) rprm_sec_mpos = ipos

         ! logging
         call mntr_mod_get_info(mname,ipos,mid)
         llog='Module ['//trim(mname)//'] registered section '
         llog=trim(llog)//' '//trim(lname)//': '//trim(ldscr)
         call mntr_log(rprm_id,lp_inf,trim(llog))
      endif

      return
      end subroutine
!=======================================================================
!> @brief Check if section name is registered and return its id. Check mid as well.
!! @ingroup runparam
!! @param[out] rpid     section id
!! @param[in]  mid      registering module id
!! @param[in]  pname    section name
      subroutine rprm_sec_is_name_reg(rpid,mid,pname)
      implicit none

      include 'SIZE'
      include 'PARALLEL'        ! ISIZE
      include 'FRAMELP'
      include 'RPRMD'

      ! argument list
      integer rpid, mid
      character*(*) pname

      ! local variables
      character*3 str
      character*10  mname
      character*20  lname
      character*132 llog
      integer slen,slena

      integer il, ipos
!-----------------------------------------------------------------------
      ! check name length
      slena = len_trim(adjustl(pname))
      ! remove trailing blanks
      slen = len_trim(pname) - slena + 1
      if (slena.gt.rprm_lstl_mnm) then
         call mntr_log(rprm_id,lp_deb,
     $        'too long section name; shortenning')
         slena = min(slena,rprm_lstl_mnm)
      endif
      call blank(lname,rprm_lstl_mnm)
      lname= pname(slen:slen+slena- 1)
      call capit(lname,slena)

      ! find parameter
      ipos = 0

      ! to ensure consistency I do it on master and broadcast result
      if (nid.eq.rprm_pid0) then

         ! check if parameter name is already registered
         do il=1,rprm_sec_mpos
            if (rprm_sec_id(il).gt.0.and.
     $          rprm_sec_name(il).eq.lname) then
               ipos = il
               exit
            endif
         enddo

      endif

      ! broadcast ipos
      call bcast(ipos,isize)

      if (ipos.eq.0) then
         rpid = -1
         call mntr_log(rprm_id,lp_inf,
     $        'Section '//trim(lname)//' not registered')
      else
         rpid = ipos
         write(str,'(I3)') ipos
         call mntr_log(rprm_id,lp_vrb,
     $   'Section '//trim(lname)//' registered with id = '//trim(str))
         ! check module
         if (mid.ne.rprm_sec_id(ipos)) then
            call mntr_log(rprm_id,lp_inf,
     $      "Section's "//trim(lname)//" module inconsistent")
            rpid = -1
         endif
      endif

      return
      end subroutine
!=======================================================================
!> @brief Check if section id is registered. This operation is performed locally
!! @ingroup runparam
!! @param[in]  rpid     section id
!! @return rprm_sec_is_id_reg
      logical function rprm_sec_is_id_reg(rpid)
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'RPRMD'

      ! argument list
      integer rpid
!-----------------------------------------------------------------------
      rprm_sec_is_id_reg = rprm_sec_id(rpid).gt.0

      return
      end function
!=======================================================================
!> @brief Get section info based on its id. This operation is performed locally
!! @ingroup runparam
!! @param[out]    pname    section name
!! @param[out]    mid      registering module id
!! @param[out]    ifact    activation flag
!! @param[inout]  rpid     section id
      subroutine rprm_sec_get_info(pname,mid,ifact,rpid)
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'RPRMD'

      ! argument list
      integer rpid, mid
      character*20 pname
      logical ifact

      ! local variables
      character*5 str
!-----------------------------------------------------------------------
      if (rprm_sec_id(rpid).gt.0) then
         pname = rprm_sec_name(rpid)
         mid = rprm_sec_id(rpid)
         ifact = rprm_sec_act(rpid)
      else
         write(str,'(I3)') rpid
         call mntr_log(rprm_id,lp_inf,
     $        'Section id'//trim(str)//' not registered')
         rpid = -1
      endif

      return
      end subroutine
!=======================================================================
!> @brief Set section's activation flag. Master value is broadcasted.
!! @details This routine is added because Nek5000 uses existence of
!!    section in .par file itself as a variable, what introduces problem
!!    with their registration as sections should be registered before reading
!!    runtime parameter file. That is why I decided to split registration
!!    and activation stages. One can register all the possible sections
!!    and activate those present in .par
!! @ingroup runparam
!! @param[in]  ifact    activation flag
!! @param[in]  rpid     runtime parameter id
      subroutine rprm_sec_set_act(ifact,rpid)
      implicit none

      include 'SIZE'
      include 'PARALLEL'
      include 'FRAMELP'
      include 'RPRMD'

      ! argument list
      integer rpid
      logical ifact

      ! local variables
      logical lval
      character*5 str
!-----------------------------------------------------------------------
      if (rprm_sec_id(rpid).gt.0) then
         ! broadcast pval; to keep consistency
         lval = ifact
         call bcast(lval,lsize)
         rprm_sec_act(rpid) = lval
      else
         write(str,'(I3)') rpid
         call mntr_abort(rprm_id,
     $          "Section "//trim(str)//" activation error")
      endif

      return
      end subroutine
!=======================================================================
!> @brief Check if section id is registered and activated. This operation is performed locally
!! @ingroup runparam
!! @param[in]  rpid     section id
!! @return rprm_sec_id_id_act
      logical function rprm_sec_is_id_act(rpid)
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'RPRMD'

      ! argument list
      integer rpid
!-----------------------------------------------------------------------
      rprm_sec_is_id_act = rprm_sec_id(rpid).gt.0.and.
     $                     rprm_sec_act(rpid)

      return
      end function
!=======================================================================
!> @brief Register new runtime parameter
!! @ingroup runparam
!! @param[out] rpid     current runtime parameter id
!! @param[in]  mid      section id
!! @param[in]  pname    parameter name
!! @param[in]  pdscr    paramerer description
!! @param[in]  ptype    parameter type
!! @param[in]  ipval    integer default value
!! @param[in]  rpval    real default value
!! @param[in]  lpval    logical default value
!! @param[in]  cpval    string default value
      subroutine rprm_rp_reg(rpid,mid,pname,pdscr,ptype ,
     $ ipval, rpval, lpval, cpval)
      implicit none

      include 'SIZE'
      include 'PARALLEL'        ! ISIZE
      include 'FRAMELP'
      include 'RPRMD'


      ! argument list
      integer rpid, mid, ptype, ipval
      real rpval
      logical lpval
      character*(*) pname, pdscr, cpval

      ! local variables
      character*10  mname
      character*20  lname
      character*132 ldscr
      character*200 llog
      integer slen,slena

      integer il, ipos
      integer ivall
      real rvall
      logical lvall
      character*20 cvall

      ! functions
      logical rprm_sec_is_id_reg
!-----------------------------------------------------------------------
      ! check name length
      slena = len_trim(adjustl(pname))
      ! remove trailing blanks
      slen = len_trim(pname) - slena + 1
      if (slena.gt.rprm_lstl_mnm) then
         call mntr_log(rprm_id,lp_deb,
     $        'too long parameter name; shortenning')
         slena = min(slena,rprm_lstl_mnm)
      endif
      call blank(lname,rprm_lstl_mnm)
      lname= pname(slen:slen+slena- 1)
      call capit(lname,slena)

      ! check description length
      slena = len_trim(adjustl(pdscr))
      ! remove trailing blanks
      slen = len_trim(pdscr) - slena + 1
      if (slena.ge.rprm_lstl_mds) then
         call mntr_log(rprm_id,lp_deb,
     $        'too long parameter description; shortenning')
         slena = min(slena,rprm_lstl_mnm)
      endif
      call blank(ldscr,rprm_lstl_mds)
      ldscr= pdscr(slen:slen + slena - 1)

      ! find empty space
      ipos = 0

      ! to ensure consistency I do it on master and broadcast result
      if (nid.eq.rprm_pid0) then

         ! check if parameter name is already registered
         do il=1,rprm_par_mpos
            if (rprm_par_id(rprm_par_mark,il).gt.0.and.
     $          rprm_par_name(il).eq.lname) then
               ipos = -il
               exit
            endif
         enddo

         ! find empty spot
         if (ipos.eq.0) then
            do il=1,rprm_par_id_max
               if (rprm_par_id(rprm_par_mark,il).eq.-1) then
                  ipos = il
                  exit
               endif
            enddo
         endif
      endif

      ! broadcast ipos
      call bcast(ipos,isize)

      ! error; no free space found
      if (ipos.eq.0) then
         rpid = ipos
         call mntr_abort(rprm_id,
     $        'Parameter '//trim(lname)//' cannot be registered')
      ! parameter already registered
      elseif (ipos.lt.0) then
         rpid = abs(ipos)
         call mntr_abort(rprm_id,
     $    'Parameter '//trim(lname)//' is already registered')
         ! new parameter
      else
         rpid = ipos
         ! check if section is registered
         if (rprm_sec_is_id_reg(mid)) then
            rprm_par_id(rprm_par_mark,ipos) = mid
         else
            call mntr_abort(rprm_id,
     $          "Parameter's "//trim(lname)//" section not registered")
         endif
         rprm_par_id(rprm_par_type,ipos) = ptype
         rprm_par_name(ipos)=lname
         rprm_par_dscr(ipos)=ldscr
         rprm_par_num = rprm_par_num + 1
         if (rprm_par_mpos.lt.ipos) rprm_par_mpos = ipos

         ! broadcast pval; to keep consistency
         if (ptype.eq.rpar_int) then
            ivall = ipval
            call bcast(ivall,isize)
            rprm_parv_int(ipos) = ivall
         elseif (ptype.eq.rpar_real) then
            rvall = rpval
            call bcast(rvall,wdsize)
            rprm_parv_real(ipos) = rvall
         elseif (ptype.eq.rpar_log) then
            lvall = lpval
            call bcast(lvall,lsize)
            rprm_parv_log(ipos) = lvall
         elseif (ptype.eq.rpar_str) then
            ! check value length
            slena = len_trim(adjustl(cpval))
            ! remove trailing blanks
            slen = len_trim(cpval) - slena + 1
            if (slena.gt.rprm_lstl_mnm) then
               call mntr_log(rprm_id,lp_deb,
     $           'too long parameter default value; shortenning')
               slena = min(slena,rprm_lstl_mnm)
            endif
            call blank(cvall,rprm_lstl_mnm)
            cvall= cpval(slen:slen+slena- 1)
            ! broadcast pval; to keep consistency
            call bcast(cvall,rprm_lstl_mnm*csize)
            rprm_parv_str(ipos) = cvall
         else
            call mntr_abort(rprm_id,
     $      "Parameter's "//trim(lname)//" wrong type")
         endif

         ! logging
         mname = trim(rprm_sec_name(mid))
         llog='Section '//trim(mname)//' registered parameter '
         llog=trim(llog)//' '//trim(lname)//': '//trim(ldscr)
         call mntr_log(rprm_id,lp_inf,trim(llog))
         if (ptype.eq.rpar_int) then
            call mntr_logi(rprm_id,lp_vrb,
     $       'Default value '//trim(lname)//' = ',ivall)
         elseif (ptype.eq.rpar_real) then
            call mntr_logr(rprm_id,lp_vrb,
     $       'Default value '//trim(lname)//' = ',rvall)
         elseif (ptype.eq.rpar_log) then
            call mntr_logl(rprm_id,lp_vrb,
     $       'Default value '//trim(lname)//' = ',lvall)
         elseif (ptype.eq.rpar_str) then
            call mntr_log(rprm_id,lp_vrb,
     $       'Default value '//trim(lname)//' = '//trim(cvall))
         endif
      endif

      return
      end subroutine
!=======================================================================
!> @brief Check if parameter name is registered and return its id. Check flags as well.
!! @ingroup runparam
!! @param[out] rpid     runtime parameter id
!! @param[in]  mid      section id
!! @param[in]  pname    parameter name
!! @param[in]  ptype    parameter type
      subroutine rprm_rp_is_name_reg(rpid,mid,pname,ptype)
      implicit none

      include 'SIZE'
      include 'PARALLEL'        ! ISIZE
      include 'FRAMELP'
      include 'RPRMD'

      ! argument list
      integer rpid, mid, ptype
      character*(*) pname

      ! local variables
      character*3 str
      character*10  mname
      character*20  lname
      character*132 llog
      integer slen,slena

      integer il, ipos
!-----------------------------------------------------------------------
      ! check name length
      slena = len_trim(adjustl(pname))
      ! remove trailing blanks
      slen = len_trim(pname) - slena + 1
      if (slena.gt.rprm_lstl_mnm) then
         call mntr_log(rprm_id,lp_deb,
     $        'too long parameter name; shortenning')
         slena = min(slena,rprm_lstl_mnm)
      endif
      call blank(lname,rprm_lstl_mnm)
      lname= pname(slen:slen+slena- 1)
      call capit(lname,slena)

      ! find parameter
      ipos = 0

      ! to ensure consistency I do it on master and broadcast result
      if (nid.eq.rprm_pid0) then

         ! check if parameter name is already registered
         do il=1,rprm_par_mpos
            if (rprm_par_id(rprm_par_mark,il).gt.0.and.
     $          rprm_par_name(il).eq.lname) then
               ipos = il
               exit
            endif
         enddo

      endif

      ! broadcast ipos
      call bcast(ipos,isize)

      if (ipos.eq.0) then
         rpid = -1
         call mntr_log(rprm_id,lp_inf,
     $        'Parameter '//trim(lname)//' not registered')
      else
         rpid = ipos
         write(str,'(I3)') ipos
         call mntr_log(rprm_id,lp_vrb,
     $   'Parameter '//trim(lname)//' registered with id = '//trim(str))
         ! check module
         if (mid.ne.rprm_par_id(rprm_par_mark,ipos)) then
            call mntr_log(rprm_id,lp_inf,
     $      "Parameter's "//trim(lname)//" section inconsistent")
            rpid = -1
         endif
         ! check type
         if (ptype.ne.rprm_par_id(rprm_par_type,ipos)) then
            call mntr_log(rprm_id,lp_inf,
     $      "Parameter's "//trim(lname)//" type inconsistent")
            rpid = -1
         endif
      endif

      return
      end subroutine
!=======================================================================
!> @brief Check if parameter id is registered and check type consistency. This operation is performed locally
!! @ingroup runparam
!! @param[in]  rpid     runtime parameter id
!! @param[in]  ptype    parameter type
!! @return rprm_rp_is_id_reg
      logical function rprm_rp_is_id_reg(rpid,ptype)
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'RPRMD'

      ! argument list
      integer rpid, ptype
!-----------------------------------------------------------------------
      rprm_rp_is_id_reg = rprm_par_id(rprm_par_mark,rpid).gt.0.and.
     $                    rprm_par_id(rprm_par_type,rpid).eq.ptype

      return
      end function
!=======================================================================
!> @brief Get parameter info based on its id. This operation is performed locally
!! @ingroup runparam
!! @param[out]    pname    parameter name
!! @param[out]    mid      section id
!! @param[out]    ptype    parameter type
!! @param[inout]  rpid     runtime parameter id
      subroutine rprm_rp_get_info(pname,mid,ptype,rpid)
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'RPRMD'

      ! argument list
      integer rpid, mid, ptype
      character*20 pname

      ! local variables
      character*5 str
!-----------------------------------------------------------------------
      if (rprm_par_id(rprm_par_mark,rpid).gt.0) then
         pname = rprm_par_name(rpid)
         mid = rprm_par_id(rprm_par_mark,rpid)
         ptype = rprm_par_id(rprm_par_type,rpid)
      else
         write(str,'(I3)') rpid
         call mntr_log(rprm_id,lp_inf,
     $        'Parameter id'//trim(str)//' not registered')
         rpid = -1
      endif

      return
      end subroutine
!=======================================================================
!> @brief Set runtime parameter of active section. Master value is broadcasted.
!! @ingroup runparam
!! @param[in]  rpid     runtime parameter id
!! @param[in]  ptype    parameter type
!! @param[in]  ipval    integer value
!! @param[in]  rpval    real value
!! @param[in]  lpval    logical value
!! @param[in]  cpval    string value
      subroutine rprm_rp_set(rpid,ptype,ipval,rpval,lpval,cpval)
      implicit none

      include 'SIZE'
      include 'PARALLEL'
      include 'FRAMELP'
      include 'RPRMD'

      ! argument list
      integer rpid, ptype
      integer ipval
      real rpval
      logical lpval
      character*(*) cpval

      ! local variables
      integer ivall
      real rvall
      logical lvall
      character*20 cvall
      character*5 str
      integer slen,slena

!-----------------------------------------------------------------------
      if (rprm_par_id(rprm_par_mark,rpid).gt.0.and.
     $    rprm_par_id(rprm_par_type,rpid).eq.ptype) then
         if(rprm_sec_act(rprm_par_id(rprm_par_mark,rpid))) then
            ! broadcast pval; to keep consistency
            if (ptype.eq.rpar_int) then
               ivall = ipval
               call bcast(ivall,isize)
               rprm_parv_int(rpid) = ivall
            elseif (ptype.eq.rpar_real) then
               rvall = rpval
               call bcast(rvall,wdsize)
               rprm_parv_real(rpid) = rvall
            elseif (ptype.eq.rpar_log) then
               lvall = lpval
               call bcast(lvall,lsize)
               rprm_parv_log(rpid) = lvall
            elseif (ptype.eq.rpar_str) then
               ! check value length
               slena = len_trim(adjustl(cpval))
               ! remove trailing blanks
               slen = len_trim(cpval) - slena + 1
               if (slena.gt.rprm_lstl_mnm) then
                  call mntr_log(rprm_id,lp_deb,
     $           'too long parameter value; shortenning')
                  slena = min(slena,rprm_lstl_mnm)
               endif
               call blank(cvall,rprm_lstl_mnm)
               cvall= cpval(slen:slen+slena- 1)
               ! broadcast pval; to keep consistency
               call bcast(cvall,rprm_lstl_mnm*csize)
               rprm_parv_str(rpid) = cvall
            else
               write(str,'(I3)') rpid
               call mntr_abort(rprm_id,
     $         "Parameter set "//trim(str)//" wrong type")
            endif
         else
            write(str,'(I3)') rpid
               call mntr_warn(rprm_id,
     $         "Parameter set "//trim(str)//" section not active")
         endif
      else
         write(str,'(I3)') rpid
         call mntr_abort(rprm_id,
     $          "Parameter "//trim(str)//" setting error")
      endif

      return
      end subroutine
!=======================================================================
!> @brief Get runtime parameter form active section. This operation is performed locally
!! @ingroup runparam
!! @param[out]  ipval    integer value
!! @param[out]  rpval    real value
!! @param[out]  lpval    logical value
!! @param[out]  cpval    string value
!! @param[in]   rpid     runtime parameter id
!! @param[in]   ptype    parameter type
      subroutine rprm_rp_get(ipval,rpval,lpval,cpval,rpid,ptype)
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'RPRMD'

      ! argument list
      integer rpid, ptype
      integer ipval
      real rpval
      logical lpval
      character*20 cpval

      ! local variables
      character*5 str
!-----------------------------------------------------------------------
      if (rprm_par_id(rprm_par_mark,rpid).gt.0.and.
     $    rprm_par_id(rprm_par_type,rpid).eq.ptype) then
         if(rprm_sec_act(rprm_par_id(rprm_par_mark,rpid))) then

            if (ptype.eq.rpar_int) then
               ipval = rprm_parv_int(rpid)
            elseif (ptype.eq.rpar_real) then
               rpval = rprm_parv_real(rpid)
            elseif (ptype.eq.rpar_log) then
               lpval = rprm_parv_log(rpid)
            elseif (ptype.eq.rpar_str) then
               cpval = rprm_parv_str(rpid)
            else
               write(str,'(I3)') rpid
               call mntr_abort(rprm_id,
     $      "Parameter get "//trim(str)//" wrong type")
            endif
         else
            write(str,'(I3)') rpid
            call mntr_warn(rprm_id,
     $         "Parameter get "//trim(str)//" section not active")
         endif
      else
         write(str,'(I3)') rpid
         call mntr_abort(rprm_id,
     $          "Parameter "//trim(str)//" getting error")
      endif

      return
      end subroutine
!=======================================================================
!> @brief Get runtime parameter from nek parser dictionary
!! @ingroup runparam
      subroutine rprm_dict_get()
      implicit none

      include 'SIZE'
      include 'PARALLEL'
      include 'FRAMELP'
      include 'RPRMD'

      ! local variables
      integer il, jl, kl
      integer nkey, ifnd, i_out
      integer nmod, pmid
      character*132 key, lkey
      character*1024 val
      logical ifoundm, ifoundp, ifact
      integer itmp
      real rtmp

      character*20  lname
      character*132 ldscr
      character*200 llog
      integer slen,slena

!-----------------------------------------------------------------------
      ! dictionary exists on master node only
      if (nid.eq.rprm_pid0) then
        ! key number in dictionary
        call finiparser_getdictentries(nkey)

        do il=1,nkey!rprm_par_mpos

          ! get a key
          call finiparser_getpair(key,val,il,ifnd)
          key = adjustl(key)
          call capit(key,132)

          ! find section key belongs to
          ifoundm=.false.
          do jl=1,rprm_sec_mpos
            if (rprm_sec_id(jl).gt.0) then
              lname=trim(adjustl(rprm_sec_name(jl)))
              ifnd = index(key,trim(lname))
              if (ifnd.eq.1) then
                ! set section to active
                rprm_sec_act(jl) = .true.
                ifoundm=.true.
                ! looking for more than section name
                if (trim(key).ne.trim(lname)) then
                  ! add variable name
                  ifoundp =.false.
                  do kl=1,rprm_par_mpos
                    if (rprm_par_id(rprm_par_mark,kl).eq.jl) then
                      lkey = trim(lname)//':'//trim(rprm_par_name(kl))
                      if (trim(key).eq.trim(lkey)) then
                        ifoundp=.true.
                        ! read parameter value
                        if (rprm_par_id(rprm_par_type,kl).eq.
     $                      rpar_int) then
                          read(val,*) itmp
                          rprm_parv_int(kl) = itmp
                        elseif (rprm_par_id(rprm_par_type,kl).eq.
     $                      rpar_real) then
                          read(val,*) rtmp
                          rprm_parv_real(kl) = rtmp
                        elseif (rprm_par_id(rprm_par_type,kl).eq.
     $                      rpar_log) then
                          call finiparser_getBool(i_out,trim(lkey),ifnd)
                          if (ifnd.eq.1) then
                            if (i_out.eq.1) then
                              rprm_parv_log(kl) = .true.
                            else
                              rprm_parv_log(kl) = .false.
                            endif
                          else
                            call mntr_warn(rprm_id,
     $               'Boolean parameter reading error '//trim(key))
                          endif
                        elseif (rprm_par_id(rprm_par_type,kl).eq.
     $                      rpar_str) then
                          rprm_parv_str(kl) = trim(adjustl(val))
                        else
                          call mntr_warn(rprm_id,
     $               'Runtime parameter type missmatch '//trim(key))
                        endif
                        exit
                      endif
                    endif
                  enddo
                  ! is it unknown parameter
                  if (.not.ifoundp) then
                    call mntr_warn(rprm_id,
     $               'Unknown runtime parameter '//trim(key))
                  endif
                endif
              exit
              endif
            endif
          enddo
          if (.not.ifoundm) then
          ! possible palce for warning that section not found
          endif
        enddo
      endif

      ! broadcast array data
      call bcast(rprm_parv_int,rprm_par_id_max*isize)
      call bcast(rprm_parv_real,rprm_par_id_max*wdsize)
      call bcast(rprm_parv_log,rprm_par_id_max*lsize)
      call bcast(rprm_parv_str,rprm_par_id_max*rprm_lstl_mnm*csize)

      ! broadcast activation lfag
      call bcast(rprm_sec_act,rprm_sec_id_max*lsize)

      return
      end subroutine
!=======================================================================
!> @brief Print out summary of registered runtime parameters (active sections only)
!! @ingroup runparam
!! @param[in]  unit   I/O unit (6 - standard I/O)
      subroutine rprm_rp_summary_print(unit)
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'RPRMD'

      ! argument list
      integer unit

      ! local variables
      integer ind(rprm_par_id_max)
      integer offset(2,rprm_par_id_max)
      integer slist(2,rprm_par_id_max), itmp1(2)
      integer npos, nset, key
      integer il, jl
      integer istart, in, itest
      character*20 str
      character*22 sname
      character*(*) cmnt
      parameter (cmnt='#')

      ! functions
      integer mntr_lp_def_get
!-----------------------------------------------------------------------
      if (unit.eq.6) then
         call mntr_log(rprm_id,lp_prd,
     $   'Summary of registered runtime parameters for active sections')
      else
         call mntr_log(rprm_id,lp_prd,
     $   'Generated .par file for active sections')
      endif

      if (nid.eq.rprm_pid0) then

         ! sort module index array
         ! copy data removing possible empty slots
         npos=0
         do il=1,rprm_par_mpos
            in = rprm_par_id(rprm_par_mark,il)
            if (in.ge.0.and.rprm_sec_act(in)) then
               npos = npos + 1
               slist(1,npos) = in
               slist(2,npos) = il
            endif
         enddo

         ! sort with respect to section id
         key = 1
         call ituple_sort(slist,2,npos,key,1,ind,itmp1)

         ! sort parameters in single section with respect to parameter id
         nset = 0
         istart = 1
         itest = slist(1,istart)
         do il=1,npos
            if(itest.ne.slist(1,il).or.il.eq.npos) then
              if (il.eq.npos.and.itest.eq.slist(1,il)) then
                 jl = npos + 1
              else
                 jl = il
              endif
              in = jl - istart
              if (in.gt.1) then
                 key = 2
                 call ituple_sort(slist(1,istart),2,in,key,1,ind,itmp1)
              endif
              nset = nset +1
              offset(1,nset) = istart
              offset(2,nset) = in
              if (il.ne.npos) then
                 itest = slist(1,il)
                 istart = il
              elseif(itest.ne.slist(1,il)) then
                 nset = nset +1
                 offset(1,nset) = il
                 offset(2,nset) = 1
              endif
            endif
         enddo

         if (mntr_lp_def_get().le.lp_prd.or.unit.ne.6) then
           if (unit.ne.6) then
             write(unit,'(A)') cmnt
             write(unit,'(A,A)') cmnt,
     $            ' runtime parameter file generated by'
             write(unit,'(A,A)') cmnt,' rprm_rp_summary_print'
             write(unit,'(A)') cmnt
           endif
           do il=1,nset
             istart = offset(1,il)
             in = offset(2,il)
             key = rprm_sec_id(slist(1,istart))
             sname = '['//trim(rprm_sec_name(slist(1,istart)))//']'
             write(unit,'(A)') cmnt
             write(unit,'(A,A)') sname,
     $   '  '//cmnt//' '//trim(adjustl(rprm_sec_dscr(slist(1,istart))))
             do jl = 0, in-1
               key = slist(2,istart+jl)
               if (rprm_par_id(rprm_par_type,key).eq.
     $             rpar_int) then
                 write(str,'(I8)') rprm_parv_int(key)
               elseif (rprm_par_id(rprm_par_type,key).eq.
     $             rpar_real) then
                 write(str,'(E15.8)') rprm_parv_real(key)
               elseif (rprm_par_id(rprm_par_type,key).eq.
     $             rpar_log) then
                 if (rprm_parv_log(key)) then
                   str = 'yes'
                 else
                   str = 'no'
                 endif
               elseif (rprm_par_id(rprm_par_type,key).eq.
     $             rpar_str) then
                 str = rprm_parv_str(key)
               endif
               write(unit,'(A," = ",A,A)')
     $           rprm_par_name(key), adjustl(str),
     $           '   '//cmnt//' '//trim(adjustl(rprm_par_dscr(key)))
             enddo
           enddo
           if (unit.ne.6) then
             write(unit,'(A)') cmnt
             write(unit,'(A,A)') cmnt,' end of runtime parameter file'
             write(unit,'(A)') cmnt
           else
             write(unit,'(A1)') ' '
           endif
         endif
      endif


      return
      end subroutine
!=======================================================================
!> @brief Check consistency of module's runtime parameters
!! @ingroup runparam
!! @param[in]    mod_nkeys    number of module's keys
!! @param[in]    mod_dictkey  module's dictionary keys
!! @param[in]    mod_n3dkeys  number of keys used for 3D run only
!! @param[in]    mod_l3dkey   list of positions of 3D keys
!! @param[out]   ifsec        is section present
!! @details Check if the section name shows up and runtime parameters are
!!  spelled correctly. Give warning if section is missing, or the key is
!!  unknown. Check possible 2D - 3D parameter mismatch.
!! @warning This routine deprecated.
      subroutine rprm_check(mod_nkeys, mod_dictkey, mod_n3dkeys,
     $           mod_l3dkey, ifsec)
      implicit none

      include 'SIZE'
      include 'INPUT'    ! IF3D
      include 'FRAMELP'
      include 'RPRMD'

      ! argument list
      integer mod_nkeys, mod_n3dkeys, mod_l3dkey(mod_n3dkeys)
      character*132 mod_dictkey(mod_nkeys)
      logical ifsec

      ! local variables
      integer il, jl, ip  ! loop index
      ! dictionary operations
      integer nkey, ifnd, i_out
      real d_out
      character*132 key, lkey
      character*1024 val
      logical ifvar, if3dkey
!-----------------------------------------------------------------------
      ! check consistency
      ! key number in dictionary
      call finiparser_getdictentries(nkey)

      ! set marker for finding module's section
      ifsec = .FALSE.
      do il=1,nkey
         ! get a key
         call finiparser_getpair(key,val,il,ifnd)
         call capit(key,132)

         ! does it belong to current module's section
         ifnd = index(key,trim(mod_dictkey(1)))
         if (ifnd.eq.1) then
            ! section was found, check variable
            ifsec = .TRUE.
            ifvar = .FALSE.
            do ip = mod_nkeys,1,-1
               lkey = trim(adjustl(mod_dictkey(1)))
               if (ip.gt.1) lkey =trim(adjustl(lkey))//
     $            ':'//trim(adjustl(mod_dictkey(ip)))
               if(index(key,trim(lkey)).eq.1) then
                  ifvar = .TRUE.
                  exit
               endif
            enddo

            if (ifvar) then
               ! check 2D versus 3D
               if (.not.IF3D) then
                  if3dkey = .FALSE.
                  do jl=1,mod_n3dkeys
                     if (ip.eq.mod_l3dkey(jl)) then
                        if3dkey = .TRUE.
                        exit
                     endif
                  enddo

                  if (if3dkey) then
                     call mntr_log(rprm_id,lp_inf,
     $                   'Module '//trim(mod_dictkey(1)))
                     call mntr_log(rprm_id,lp_inf,
     $              '3D parameter '//trim(key)//' specified for 2D run')
                  endif
               endif
            else
               ! variable not found
               call mntr_log(rprm_id,lp_inf,
     $              'Module '//trim(mod_dictkey(1)))
               call mntr_log(rprm_id,lp_inf,
     $              'Unknown runtime parameter: '//trim(key))
            endif
         endif
      enddo

      ! no parameter section; give warning
      if (.not.ifsec) then
         call mntr_log(rprm_id,lp_inf,'Module '//trim(mod_dictkey(1)))
         call mntr_log(rprm_id,lp_inf,
     $     'runtime parameter section not found.')
      endif

      return
      end subroutine
!=======================================================================



!> @file mntrtmr_block.f
!! @ingroup monitor
!! @brief Block data to initialise common blocks in MNTRTMRD
!! @details Following Nek5000 standard I keep block data in seaprate file.
!! @author Adam Peplinski
!! @date Oct 13, 2017
!=======================================================================
      block data mntr_tmr_common_init
      include 'MNTRLOGD'
      include 'MNTRTMRD'

      data mntr_tmr_num /0/
      data mntr_tmr_mpos /0/
      data mntr_tmr_id /mntr_tmr_id_size*-1/
      data mntr_tmr_sum /mntr_tmr_id_max*.false./
      data mntr_tmr_name /mntr_tmr_id_max*mntr_blname/
      data mntr_tmrv_timer /mntr_tmr_id_size*0.0/

      end



!> @file mntrtmr.f
!! @ingroup monitor
!! @brief Set of timer database routines for KTH framework
!! @author Adam Peplinski
!! @date Oct 13, 2017
!=======================================================================
!> @brief Register new timer
!! @ingroup monitor
!! @param[out] mid      new timer id
!! @param[in]  pmid     parent timer id
!! @param[in]  modid    registerring module id
!! @param[in]  mname    timer name
!! @param[in]  mdscr    timer description
!! @param[in]  ifsum    add timer to parent
      subroutine mntr_tmr_reg(mid,pmid,modid,mname,mdscr,ifsum)
      implicit none

      include 'SIZE'
      include 'PARALLEL'        ! ISIZE
      include 'MNTRLOGD'
      include 'MNTRTMRD'
      include 'FRAMELP'

      ! argument list
      integer mid, pmid, modid
      character*(*) mname, mdscr
      logical ifsum

      ! local variables
      character*10  lname
      character*132 ldscr
      integer slen,slena

      integer il, ipos
!-----------------------------------------------------------------------
      ! check name length
      slena = len_trim(adjustl(mname))
      ! remove trailing blanks
      slen = len_trim(mname) - slena + 1
      if (slena.gt.mntr_lstl_mnm) then
         call mntr_log(mntr_id,lp_deb,
     $        'too long timer name; shortenning')
         slena = min(slena,mntr_lstl_mnm)
      endif
      call blank(lname,mntr_lstl_mnm)
      lname= mname(slen:slen+slena- 1)
      call capit(lname,slena)

      ! check description length
      slena = len_trim(adjustl(mdscr))
      ! remove trailing blanks
      slen = len_trim(mdscr) - slena + 1
      if (slena.ge.mntr_lstl_mds) then
         call mntr_log(mntr_id,lp_deb,
     $        'too long timer description; shortenning')
         slena = min(slena,mntr_lstl_mnm)
      endif
      call blank(ldscr,mntr_lstl_mds)
      ldscr= mdscr(slen:slen + slena - 1)

      ! find empty space
      ipos = 0

      ! to ensure consistency I do it on master and broadcast result
      if (nid.eq.mntr_pid0) then

         ! check if module is already registered
         do il=1,mntr_tmr_mpos
            if (mntr_tmr_id(mntr_tmr_mark,il).ge.0.and.
     $         mntr_tmr_name(il).eq.lname) then
               ipos = -il
               exit
            endif
         enddo

         ! find empty spot
         if (ipos.eq.0) then
            do il=1,mntr_tmr_id_max
               if (mntr_tmr_id(mntr_tmr_mark,il).eq.-1) then
                  ipos = il
                  exit
               endif
            enddo
         endif
      endif

      ! broadcast mid
      call bcast(ipos,isize)

      ! error; no free space found
      if (ipos.eq.0) then
         mid = ipos
         call mntr_abort(mntr_id,
     $        'timer ['//trim(lname)//'] cannot be registered')
      ! module already registered
      elseif (ipos.lt.0) then
         mid = abs(ipos)
         call mntr_abort(mntr_id,
     $    'timer ['//trim(lname)//'] is already registered')
      ! new module
      else
         mid = ipos
         ! check if parent timer is registered
         if (pmid.gt.0) then
            if (mntr_tmr_id(mntr_tmr_mark,pmid).ge.0) then
               mntr_tmr_id(mntr_tmr_mark,ipos) = pmid
            else
               mntr_tmr_id(mntr_tmr_mark,ipos) = 0
               call mntr_log(mntr_id,lp_inf,
     $       "timer's ["//trim(lname)//"] parent not registered.")
            endif
         else
            mntr_tmr_id(mntr_tmr_mark,ipos) = 0
         endif

         ! check if registerring module is registered
         if (modid.gt.0) then
            if (mntr_mod_id(modid).ge.0) then
               mntr_tmr_id(mntr_tmr_mod,ipos) = modid
            else
               mntr_tmr_id(mntr_tmr_mod,ipos) = 0
               call mntr_log(mntr_id,lp_inf,
     $       "timer's ["//trim(lname)//"] module not registered.")
            endif
         else
            mntr_tmr_id(mntr_tmr_mod,ipos) = 0
         endif

         mntr_tmr_name(ipos)=lname
         mntr_tmr_dscr(ipos)=ldscr
         mntr_tmr_sum(ipos)=ifsum
         mntr_tmr_num = mntr_tmr_num + 1
         if (mntr_tmr_mpos.lt.ipos) mntr_tmr_mpos = ipos
         call mntr_log(mntr_id,lp_inf,
     $       'Registered timer ['//trim(lname)//']: '//trim(ldscr))
      endif

      return
      end subroutine
!=======================================================================
!> @brief Check if timer name is registered and return its id.
!! @ingroup monitor
!! @param[out] mid      timer id
!! @param[in]  mname    timer name
      subroutine mntr_tmr_is_name_reg(mid,mname)
      implicit none

      include 'SIZE'
      include 'PARALLEL'        ! ISIZE
      include 'MNTRLOGD'
      include 'MNTRTMRD'
      include 'FRAMELP'

      ! argument list
      integer mid
      character*(*) mname

      ! local variables
      character*10  lname
      character*3 str
      integer slen,slena

      integer il, ipos
!-----------------------------------------------------------------------
      ! check name length
      slena = len_trim(adjustl(mname))
      ! remove trailing blanks
      slen = len_trim(mname) - slena + 1
      if (slena.gt.mntr_lstl_mnm) then
         call mntr_log(mntr_id,lp_deb,
     $          'too long timer name; shortenning')
         slena = min(slena,mntr_lstl_mnm)
      endif
      call blank(lname,mntr_lstl_mnm)
      lname= mname(slen:slen+slena- 1)
      call capit(lname,slena)

      ! find module
      ipos = 0

      ! to ensure consistency I do it on master and broadcast result
      if (nid.eq.mntr_pid0) then
         ! check if module is already registered
         do il=1,mntr_tmr_mpos
            if (mntr_tmr_id(mntr_tmr_mark,il).ge.0.and.
     $         mntr_tmr_name(il).eq.lname) then
               ipos = il
               exit
            endif
         enddo
      endif

      ! broadcast ipos
      call bcast(ipos,isize)

      if (ipos.eq.0) then
         mid = -1
         call mntr_log(mntr_id,lp_inf,
     $        'timer ['//trim(lname)//'] not registered')
      else
         mid = ipos
         write(str,'(I3)') ipos
         call mntr_log(mntr_id,lp_vrb,
     $        'timer ['//trim(lname)//'] registered with id='//str)
      endif

      return
      end subroutine
!=======================================================================
!> @brief Check if timer id is registered. This operation is performed locally
!! @ingroup monitor
!! @param[in] mid      timer id
!! @return mntr_tmr_is_id_reg
      logical function mntr_tmr_is_id_reg(mid)
      implicit none

      include 'SIZE'
      include 'PARALLEL'
      include 'MNTRLOGD'
      include 'MNTRTMRD'
      include 'FRAMELP'

      ! argument list
      integer mid
!-----------------------------------------------------------------------
      mntr_tmr_is_id_reg = mntr_tmr_id(mntr_tmr_mark,mid).ge.0

      return
      end function
!=======================================================================
!> @brief Check if timer id is registered. This operation is performed locally
!! @ingroup monitor
!! @param[in] mid       timer id
!! @param[in] icount    count increase
!! @param[in] time      time increase
      subroutine mntr_tmr_add(mid,icount,time)
      implicit none

      include 'SIZE'
      include 'MNTRLOGD'
      include 'MNTRTMRD'
      include 'FRAMELP'

      ! argument list
      integer mid, icount
      real time

      ! local variables
      character*3 str
!-----------------------------------------------------------------------
      if (mntr_tmr_id(mntr_tmr_mark,mid).ge.0) then
         mntr_tmrv_timer(mntr_tmr_count,mid) =
     $        mntr_tmrv_timer(mntr_tmr_count,mid) + icount

         mntr_tmrv_timer(mntr_tmr_time,mid) =
     $        mntr_tmrv_timer(mntr_tmr_time,mid) + time
      else
         write(str,'(I3)') mid
         call mntr_log(mntr_id,lp_inf,
     $       'timer id='//trim(str)//' in mntr_tmr_add not registered')
      endif

      return
      end subroutine
!=======================================================================
!> @brief Print registered timers showing tree structure
!! @ingroup monitor
      subroutine mntr_tmr_summary_print()
      implicit none

      include 'SIZE'
      include 'MNTRLOGD'
      include 'MNTRTMRD'
      include 'FRAMELP'

      ! local variables
      integer il, jl, maxlev, stride
      parameter (stride=2)
      integer olist(2,mntr_tmr_id_max), ierr, itmp
      real timmin(mntr_tmr_id_max),timmax(mntr_tmr_id_max)
      character*35 ftm
      character*3 str

      ! functions
      integer iglmax
      real glmax, glmin, dnekclock
!-----------------------------------------------------------------------
      call mntr_log(mntr_id,lp_prd,
     $         'Summary of registered timers')

      ! finalise framework timing
      mntr_frame_tmini = dnekclock() - mntr_frame_tmini
      call mntr_tmr_add(mntr_frame_tmr_id,1,mntr_frame_tmini)

      ! get ordered list
      call mntr_tmr_get_olist(olist, ierr)
      ierr = iglmax(ierr,1)
      if (ierr.gt.0) then
         call mntr_error(mntr_id,"Inconsistent timer tree.")
         return
      endif

      ! sum contributions from children if they are marked with mntr_tmr_sum
      ! find max level for this run
      maxlev = 1
      do il=1,mntr_tmr_num
         maxlev = max(maxlev,olist(2,il))
      enddo

      do il=maxlev,1,-1
         do jl=1,mntr_tmr_num
            if (olist(2,jl).eq.il.and.mntr_tmr_sum(olist(1,jl))) then
               itmp = mntr_tmr_id(mntr_tmr_mark,olist(1,jl))
               ! sum iteration count
               mntr_tmrv_timer(mntr_tmr_count,itmp) =
     $             mntr_tmrv_timer(mntr_tmr_count,itmp) +
     $             mntr_tmrv_timer(mntr_tmr_count,olist(1,jl))
               ! sum timer
               mntr_tmrv_timer(mntr_tmr_time,itmp) =
     $             mntr_tmrv_timer(mntr_tmr_time,itmp) +
     $             mntr_tmrv_timer(mntr_tmr_time,olist(1,jl))
            endif
         enddo
      enddo


      ! get max, min timers
      do il=1,mntr_tmr_mpos
         if (mntr_tmr_id(mntr_tmr_mark,il).ge.0) then
            timmin(il) = glmin(mntr_tmrv_timer(mntr_tmr_time,il),1)
            timmax(il) = glmax(mntr_tmrv_timer(mntr_tmr_time,il),1)
         endif
      enddo

      if (nid.eq.mntr_pid0) then

         if(ierr.eq.0.and.mntr_lp_def.le.lp_prd) then

            ! modify max level
            maxlev = maxlev + 1

            ! print description
            if (mntr_iftdsc) then
               write (*,*) ' '
               do il=1,mntr_tmr_num
                  write(str,'(I3)') stride*(olist(2,il))
                  ftm = '("[",A,"]",'//trim(str)//'X,A,'
                  write(str,'(I3)') stride*(maxlev-olist(2,il))
                  ftm = trim(ftm)//trim(str)//'X,": ",A)'
                  jl = olist(1,il)
                  write(*,ftm)
     $               mntr_mod_name(mntr_tmr_id(mntr_tmr_mod,jl)),
     $               mntr_tmr_name(jl), trim(mntr_tmr_dscr(jl))
               enddo
            endif

            ! print values
            write(*,*) ' '
            write(str,'(I3)') mntr_lstl_mnm +stride*maxlev-1
            ftm='(A11,1X,A'//trim(adjustl(str))//',1X,":",4A15)'
            write(*,ftm) 'Module name','Timer name','Count','Min time',
     $                   'Max time', 'Max/count'
            do il=1,mntr_tmr_num
               write(str,'(I3)') stride*(olist(2,il))
               ftm = '("[",A,"]",'//trim(str)//'X,A,'
               write(str,'(I3)') stride*(maxlev-olist(2,il))
               ftm = trim(ftm)//trim(str)//'X,":",4E15.8)'
               jl = olist(1,il)
               write(*,ftm) mntr_mod_name(mntr_tmr_id(mntr_tmr_mod,jl)),
     $           mntr_tmr_name(jl), mntr_tmrv_timer(mntr_tmr_count,jl),
     $           timmin(jl),timmax(jl),
     $           timmax(jl)/max(1.0,mntr_tmrv_timer(mntr_tmr_count,jl))
            enddo
            write(*,*) ' '
         endif
      endif

      return
      end subroutine
!=======================================================================
!> @brief Provide ordered list of registered timers for printing.
!! @ingroup monitor
!! @param[out]   olist    ordered list
!! @param[out]   ierr     error flag
      subroutine mntr_tmr_get_olist(olist,ierr)
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'MNTRLOGD'
      include 'MNTRTMRD'

      ! argument list
      integer olist(2,mntr_tmr_id_max), ierr

      ! local variables
      integer ind(mntr_tmr_id_max), level, parent, ipos
      integer slist(2,mntr_tmr_id_max), itmp1(2)
      integer npos, key
      integer il, jl
      integer istart, in, itest
!-----------------------------------------------------------------------
      ierr = 0

      ! sort timer index array
      ! copy data removing possible empty slots
      npos=0
      do il=1,mntr_tmr_mpos
         if (mntr_tmr_id(mntr_tmr_mark,il).ge.0) then
            npos = npos + 1
            slist(1,npos) = mntr_tmr_id(mntr_tmr_mark,il)
            slist(2,npos) = il
         endif
      enddo
      if(npos.ne.mntr_tmr_num) then
         ierr = 1
         call mntr_log(mntr_id,lp_inf,
     $         'Inconsistent timer number; return')
         return
      endif

      ! sort with respect to parent id
      key = 1
      call ituple_sort(slist,2,npos,key,1,ind,itmp1)

      ! sort within children of single parent with respect to child id
      istart = 1
      itest = slist(1,istart)
      do il=1,npos
         if(itest.ne.slist(1,il).or.il.eq.npos) then
           if (il.eq.npos.and.itest.eq.slist(1,il)) then
              jl = npos + 1
           else
              jl = il
           endif
           in = jl - istart
           if (itest.eq.0.and.in.ne.1) then
              call mntr_log(mntr_id,lp_inf,
     $         'Must be single root of the graph; return')
              ierr = 2
              return
           endif
           if (in.gt.1) then
              key = 2
              call ituple_sort(slist(1,istart),2,in,key,1,ind,itmp1)
           endif
           if (il.ne.npos) then
              itest = slist(1,il)
              istart = il
           endif
         endif
      enddo

      parent = 0
      level = 0
      ipos = 1
      call mntr_build_ord_list(olist,slist,npos,ipos,parent,level)

      return
      end subroutine
!=======================================================================



!> @file mntrlog_block.f
!! @ingroup monitor
!! @brief Block data to initialise common blocks in MNTRLOGD
!! @details Following Nek5000 standard I keep block data in seaprate file.
!! @author Adam Peplinski
!! @date Sep 28, 2017
!=======================================================================
      block data mntr_log_common_init
      include 'MNTRLOGD'

      data mntr_ifinit /.false./
      data mntr_stdl /1/
      data mntr_ifconv /.false./
      data mntr_pid0 /0/
      data mntr_mod_num /0/
      data mntr_mod_mpos /0/
      data mntr_mod_id /mntr_id_max*-1/
      data mntr_mod_name /mntr_id_max*mntr_blname/

      end



!> @file mntrlog.f
!! @ingroup monitor
!! @brief Set of module register and logging routines for KTH framework
!! @author Adam Peplinski
!! @date Sep 28, 2017
!=======================================================================
!> @brief Initialise monitor by registering framework and monitor
!! @ingroup monitor
!! @param[in]  log_thr   initial log threshold
      subroutine mntr_register_mod(log_thr)
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'MNTRLOGD'
      include 'MNTRTMRD'

      ! argument list
      integer log_thr

      ! local variables
      character*2 str
      character*200 lstring

      ! functions
      integer frame_get_master
      real dnekclock
!-----------------------------------------------------------------------
      ! simple timing
      mntr_frame_tmini = dnekclock()

      ! set master node
      mntr_pid0 = frame_get_master()

      ! first register framework
      mntr_frame_id = 1
      mntr_mod_id(mntr_frame_id) = 0
      mntr_mod_name(mntr_frame_id) = mntr_frame_name
      mntr_mod_dscr(mntr_frame_id) = 'Framework backbone'
      mntr_mod_num = mntr_mod_num + 1
      mntr_mod_mpos = mntr_mod_mpos + 1

      ! next monitor
      mntr_id = 2
      mntr_mod_id(mntr_id) = mntr_frame_id
      mntr_mod_name(mntr_id) = mntr_name
      mntr_mod_dscr(mntr_id) = 'Monitoring module'
      mntr_mod_num = mntr_mod_num + 1
      mntr_mod_mpos = mntr_mod_mpos + 1

      ! set log threshold
      mntr_lp_def = log_thr

      ! log changes
      lstring ='Registered module ['//trim(mntr_mod_name(mntr_frame_id))
      lstring= trim(lstring)//']: '//trim(mntr_mod_dscr(mntr_frame_id))
      call mntr_log(mntr_id,lp_inf,trim(lstring))

      lstring = 'Registered module ['//trim(mntr_mod_name(mntr_id))
      lstring= trim(lstring)//']: '//trim(mntr_mod_dscr(mntr_id))
      call mntr_log(mntr_id,lp_inf,trim(lstring))

      ! register framework timer and get initiaisation time
      call mntr_tmr_reg(mntr_frame_tmr_id,0,mntr_frame_id,
     $     'FRM_TOT','Total elapsed framework time',.false.)

      write(str,'(I2)') mntr_lp_def
      call mntr_log(mntr_id,lp_inf,
     $     'Initial log threshold set to: '//trim(str))

      return
      end subroutine
!=======================================================================
!> @brief Register monitor runtime parameters
!! @ingroup monitor
      subroutine mntr_register_par
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'MNTRLOGD'

      ! local variables
      integer rpid,itmp
      real rtmp
      logical ltmp
      character*20 ctmp
!-----------------------------------------------------------------------
      ! register and set active section
      call rprm_sec_reg(mntr_sec_id,mntr_id,'_'//adjustl(mntr_name),
     $     'Runtime parameter section for monitor module')
      call rprm_sec_set_act(.true.,mntr_sec_id)

      ! register parameters
      call rprm_rp_reg(mntr_lp_def_id,mntr_sec_id,'LOGLEVEL',
     $     'Logging threshold for toolboxes',rpar_int,mntr_lp_def,
     $      0.0,.false.,' ')

      call rprm_rp_reg(mntr_iftdsc_id,mntr_sec_id,'IFTIMDSCR',
     $     'Write timer description in the summary',rpar_log,0,
     $      0.0,.false.,' ')

      call rprm_rp_reg(mntr_wtime_id,mntr_sec_id,'WALLTIME',
     $     'Simulation wall time',rpar_str,0,0.0,.false.,'00:00')

      return
      end subroutine
!=======================================================================
!> @brief Initialise monitor module
!! @ingroup monitor
      subroutine mntr_init
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'MNTRLOGD'

      ! local variables
      integer ierr, nhour, nmin
      integer itmp
      real rtmp
      logical ltmp
      character*20 ctmp
      character*2 str
!-----------------------------------------------------------------------
      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,mntr_lp_def_id,rpar_int)
      mntr_lp_def = itmp

      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,mntr_iftdsc_id,rpar_log)
      mntr_iftdsc = ltmp

      write(str,'(I2)') mntr_lp_def
      call mntr_log(mntr_id,lp_inf,
     $     'Reseting log threshold to: '//trim(str))

      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,mntr_wtime_id,rpar_str)
      mntr_wtimes = ctmp

      ! get wall clock
      ctmp = trim(adjustl(mntr_wtimes))
      ! check string format
      ierr = 0
      if (ctmp(3:3).ne.':') ierr = 1
      if (.not.(LGE(ctmp(1:1),'0').and.LLE(ctmp(1:1),'9'))) ierr = 1
      if (.not.(LGE(ctmp(2:2),'0').and.LLE(ctmp(2:2),'9'))) ierr = 1
      if (.not.(LGE(ctmp(4:4),'0').and.LLE(ctmp(4:4),'9'))) ierr = 1
      if (.not.(LGE(ctmp(5:5),'0').and.LLE(ctmp(5:5),'9'))) ierr = 1

      if (ierr.eq.0) then
         read(ctmp(1:2),'(I2)') nhour
         read(ctmp(4:5),'(I2)') nmin
         mntr_wtime = 60.0*(nmin +60*nhour)
      else
         call mntr_log(mntr_id,lp_inf,'Wrong wall time format')
      endif

      ! write summary
      call mntr_mod_summary_print()

      mntr_ifinit = .true.

      return
      end subroutine
!=======================================================================
!> @brief Monitor simulation wall clock
!! @ingroup monitor
      subroutine mntr_wclock
      implicit none

      include 'SIZE'
      include 'TSTEP'           ! ISTEP, NSTEPS, LASTEP
      include 'INPUT'           ! IFMVBD, IFREGUO
      include 'PARALLEL'        ! WDSIZE
      include 'CTIMER'          ! ETIMES
      include 'FRAMELP'
      include 'MNTRLOGD'

      ! local variables
      integer il, lstdl
      real rtmp
!-----------------------------------------------------------------------
      ! double delay step as monitoing routine does not know when checkpointing
      ! starts and wall clock can be reached in the middle of writnig process
      lstdl = 2*mntr_stdl+1

      ! check simulation wall time
      if (mntr_wtime.gt.0.0) then

         ! save wall time of the current step
         do il=lstdl,2,-1
            mntr_wtstep(il) = mntr_wtstep(il-1)
         enddo
         mntr_wtstep(1) = dnekclock() - ETIMES
         ! check if simulation is going to exceed wall time, but
         ! first let read all checkpointing files (necessary for multi file
         ! checkpointing)
         if (ISTEP.gt.lstdl) then
            ! it should be enough for the master to check condition
            if (NID.eq.mntr_pid0) rtmp = 2.0*mntr_wtstep(1) -
     $         mntr_wtstep(lstdl)
            ! broadcast predicted time
            il = WDSIZE
            call bcast(rtmp,il)

            if (rtmp.gt.mntr_wtime.and.(NSTEPS-ISTEP).gt.lstdl) then
               call mntr_log(mntr_id,lp_inf,
     $                 'Wall clock reached; adjust NSTEPS')
               NSTEPS = ISTEP+lstdl
            endif
         endif
      endif

      ! check convergence flag
      if (mntr_ifconv.and.(NSTEPS-ISTEP).gt.lstdl) then
         call mntr_log(mntr_id,lp_inf,
     $            'Simulation converged; adjust NSTEPS')
         NSTEPS = ISTEP+lstdl
      endif

      ! just to take into account there is istep and kstep,
      ! and kstep is just a local variable
      if (ISTEP.ge.NSTEPS) LASTEP=1

      return
      end subroutine
!=======================================================================
!> @brief Set number of steps necessary to write proper checkpointing
!! @ingroup monitor
!! @param[in] dstep   step delay
      subroutine mntr_set_step_delay(dstep)
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'MNTRLOGD'

      ! argument list
      integer dstep

!-----------------------------------------------------------------------
      if (dstep.gt.mntr_stdl_max) then
         call mntr_abort(mntr_id,"Step delay exceeds mntr_stdl_max")
      else
         mntr_stdl = max(mntr_stdl,dstep)
      endif

      return
      end subroutine
!=======================================================================
!> @brief Get step delay
!! @ingroup monitor
!! @param[out] dstep   step delay
      subroutine mntr_get_step_delay(dstep)
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'MNTRLOGD'

      ! argument list
      integer dstep
!-----------------------------------------------------------------------
      dstep = mntr_stdl

      return
      end subroutine
!=======================================================================
!> @brief Set convergence flag to shorten simulation
!! @ingroup monitor
      subroutine mntr_set_conv(ifconv)
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'MNTRLOGD'

      ! argument list
      logical ifconv

!-----------------------------------------------------------------------
      mntr_ifconv = ifconv

      return
      end subroutine
!=======================================================================
!> @brief Check if module was initialised
!! @ingroup monitor
!! @return mntr_is_initialised
      logical function mntr_is_initialised()
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'MNTRLOGD'
!-----------------------------------------------------------------------
      mntr_is_initialised = mntr_ifinit

      return
      end function
!=======================================================================
!> @brief Get logging threashold
!! @ingroup monitor
!! @return mntr_lp_def_get
      integer function mntr_lp_def_get()
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'MNTRLOGD'
!-----------------------------------------------------------------------
      mntr_lp_def_get = mntr_lp_def

      return
      end function
!=======================================================================
!> @brief Register new module
!! @ingroup monitor
!! @param[out] mid      current module id
!! @param[in]  pmid     parent module id
!! @param[in]  mname    module name
!! @param[in]  mdscr    module description
      subroutine mntr_mod_reg(mid,pmid,mname,mdscr)
      implicit none

      include 'SIZE'
      include 'PARALLEL'        ! ISIZE
      include 'FRAMELP'
      include 'MNTRLOGD'

      ! argument list
      integer mid, pmid
      character*(*) mname, mdscr

      ! local variables
      character*10  lname
      character*132 ldscr
      integer slen,slena

      integer il, ipos
!-----------------------------------------------------------------------
      ! check name length
      slena = len_trim(adjustl(mname))
      ! remove trailing blanks
      slen = len_trim(mname) - slena + 1
      if (slena.gt.mntr_lstl_mnm) then
         call mntr_log(mntr_id,lp_deb,
     $        'too long module name; shortenning')
         slena = min(slena,mntr_lstl_mnm)
      endif
      call blank(lname,mntr_lstl_mnm)
      lname= mname(slen:slen+slena- 1)
      call capit(lname,slena)

      ! check description length
      slena = len_trim(adjustl(mdscr))
      ! remove trailing blanks
      slen = len_trim(mdscr) - slena + 1
      if (slena.ge.mntr_lstl_mds) then
         call mntr_log(mntr_id,lp_deb,
     $        'too long module description; shortenning')
         slena = min(slena,mntr_lstl_mnm)
      endif
      call blank(ldscr,mntr_lstl_mds)
      ldscr= mdscr(slen:slen + slena - 1)

      ! find empty space
      ipos = 0

      ! to ensure consistency I do it on master and broadcast result
      if (nid.eq.mntr_pid0) then

         ! check if module is already registered
         do il=1,mntr_mod_mpos
            if (mntr_mod_id(il).ge.0.and.
     $         mntr_mod_name(il).eq.lname) then
               ipos = -il
               exit
            endif
         enddo

         ! find empty spot
         if (ipos.eq.0) then
            do il=1,mntr_id_max
               if (mntr_mod_id(il).eq.-1) then
                  ipos = il
                  exit
               endif
            enddo
         endif
      endif

      ! broadcast mid
      call bcast(ipos,isize)

      ! error; no free space found
      if (ipos.eq.0) then
         mid = ipos
         call mntr_abort(mntr_id,
     $        'module ['//trim(lname)//'] cannot be registered')
      !  module already registered
      elseif (ipos.lt.0) then
         mid = abs(ipos)
         call mntr_abort(mntr_id,
     $    'Module ['//trim(lname)//'] is already registered')
      ! new module
      else
         mid = ipos
         ! check if parent module is registered
         if (pmid.gt.0) then
            if (mntr_mod_id(pmid).ge.0) then
               mntr_mod_id(ipos) = pmid
            else
               mntr_mod_id(ipos) = 0
               call mntr_log(mntr_id,lp_inf,
     $       "Module's ["//trim(lname)//"] parent not registered.")
            endif
         else
            mntr_mod_id(ipos) = 0
         endif
         mntr_mod_name(ipos)=lname
         mntr_mod_dscr(ipos)=ldscr
         mntr_mod_num = mntr_mod_num + 1
         if (mntr_mod_mpos.lt.ipos) mntr_mod_mpos = ipos
         call mntr_log(mntr_id,lp_inf,
     $       'Registered module ['//trim(lname)//']: '//trim(ldscr))
      endif

      return
      end subroutine
!=======================================================================
!> @brief Check if module name is registered and return its id.
!! @ingroup monitor
!! @param[out] mid      module id
!! @param[in]  mname    module name
      subroutine mntr_mod_is_name_reg(mid,mname)
      implicit none

      include 'SIZE'
      include 'PARALLEL'        ! ISIZE
      include 'FRAMELP'
      include 'MNTRLOGD'

      ! argument list
      integer mid
      character*(*) mname

      ! local variables
      character*10  lname
      character*3 str
      integer slen,slena

      integer il, ipos
!-----------------------------------------------------------------------
      ! check name length
      slena = len_trim(adjustl(mname))
      ! remove trailing blanks
      slen = len_trim(mname) - slena + 1
      if (slena.gt.mntr_lstl_mnm) then
         call mntr_log(mntr_id,lp_deb,
     $          'too long module name; shortenning')
         slena = min(slena,mntr_lstl_mnm)
      endif
      call blank(lname,mntr_lstl_mnm)
      lname= mname(slen:slen+slena- 1)
      call capit(lname,slena)

      ! find module
      ipos = 0

      ! to ensure consistency I do it on master and broadcast result
      if (nid.eq.mntr_pid0) then
         ! check if module is already registered
         do il=1,mntr_mod_mpos
            if (mntr_mod_id(il).ge.0.and.
     $         mntr_mod_name(il).eq.lname) then
               ipos = il
               exit
            endif
         enddo
      endif

      ! broadcast ipos
      call bcast(ipos,isize)

      if (ipos.eq.0) then
         mid = -1
         call mntr_log(mntr_id,lp_inf,
     $        'Module ['//trim(lname)//'] not registered')
      else
         mid = ipos
         write(str,'(I3)') ipos
         call mntr_log(mntr_id,lp_vrb,
     $        'Module ['//trim(lname)//'] registered with mid='//str)
      endif

      return
      end subroutine
!=======================================================================
!> @brief Check if module id is registered. This operation is performed locally
!! @ingroup monitor
!! @param[in] mid      module id
!! @return mntr_mod_is_id_reg
      logical function mntr_mod_is_id_reg(mid)
      implicit none

      include 'SIZE'
      include 'PARALLEL'
      include 'FRAMELP'
      include 'MNTRLOGD'

      ! argument list
      integer mid
!-----------------------------------------------------------------------
      mntr_mod_is_id_reg = mntr_mod_id(mid).ge.0

      return
      end function
!=======================================================================
!> @brief Get number of registered modules. This operation is performed locally
!! @ingroup monitor
!! @param[out]    nmod     module number
!! @param[out]    mmod     max module id
      subroutine mntr_mod_get_number(nmod,mmod)
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'MNTRLOGD'

      ! argument list
      integer nmod, mmod
!-----------------------------------------------------------------------
      nmod = mntr_mod_num
      mmod = mntr_mod_mpos

      return
      end subroutine
!=======================================================================
!> @brief Get module name an parent id for given module id. This operation is performed locally
!! @ingroup monitor
!! @param[out]    pmid     parent module id
!! @param[out]    mname    module name
!! @param[inout]  mid      module id
      subroutine mntr_mod_get_info(mname, pmid,mid)
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'MNTRLOGD'

      ! argument list
      character*10 mname
      integer mid, pmid

      ! local variables
      character*5 str
!-----------------------------------------------------------------------
      if (mntr_mod_id(mid).ge.0) then
         pmid = mntr_mod_id(mid)
         mname = mntr_mod_name(mid)
      else
         mid = -1
         write(str,'(I3)') mid
         call mntr_log(mntr_id,lp_vrb,
     $        'Module id'//trim(str)//' not registered')
      endif

      return
      end subroutine
!=======================================================================
!> @brief Write log message
!! @ingroup monitor
!! @param[in] mid       module id
!! @param[in] priority  log priority
!! @param[in] logs      log body
      subroutine mntr_log(mid,priority,logs)
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'MNTRLOGD'

      ! argument list
      integer mid,priority
      character*(*) logs

      ! local variables
      character*200 llogs
      character*5 str
      integer slen, slena
!-----------------------------------------------------------------------
      ! check log priority
      if (priority.lt.mntr_lp_def) return

      ! done only by master
      if (nid.eq.mntr_pid0) then

         ! check description length
         slena = len_trim(adjustl(logs))
         ! remove trailing blanks
         slen = len_trim(logs) - slena + 1
         if (slena.ge.mntr_lstl_log) then
            if (mntr_lp_def.le.lp_deb) write(*,*)' ['//mntr_name//'] ',
     $       'too long log string; shortenning'
            slena = min(slena,mntr_lstl_log)
         endif
         call blank(llogs,mntr_lstl_mds)
         llogs= logs(slen:slen + slena - 1)

         ! check module id
         if (mntr_mod_id(mid).ge.0) then
            ! add module name
            write(*,*) ' ['//trim(mntr_mod_name(mid))//'] '//trim(llogs)
         else
            write(str,'(I3)') mid
            write(*,*) ' ['//trim(mntr_name)//'] ',
     $      ' WARNING: module'//trim(str)//' not registered;'
            write(*,*) 'Log body: '//trim(llogs)
         endif
      endif

      return
      end subroutine
!=======================================================================
!> @brief Write log message from given process
!! @ingroup monitor
!! @param[in] mid       module id
!! @param[in] priority  log priority
!! @param[in] logs      log body
!! @param[in] prid      process id
      subroutine mntr_log_local(mid,priority,logs,prid)
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'MNTRLOGD'

      ! argument list
      integer mid,priority, prid
      character*(*) logs

      ! local variables
      character*200 llogs
      character*5 str
      integer slen, slena
!-----------------------------------------------------------------------
      ! check log priority
      if (priority.lt.mntr_lp_def) return

      ! done only by given process

      ! check description length
      slena = len_trim(adjustl(logs))
      ! remove trailing blanks
      slen = len_trim(logs) - slena + 1
      if (slena.ge.mntr_lstl_log) then
         if (mntr_lp_def.le.lp_deb) write(*,*)' ['//mntr_name//'] ',
     $       'too long log string; shortenning'
         slena = min(slena,mntr_lstl_log)
      endif
      call blank(llogs,mntr_lstl_mds)
      llogs= logs(slen:slen + slena - 1)

      ! check module id
      if (mntr_mod_id(mid).ge.0) then
      ! add module name
       write(*,*) ' ['//trim(mntr_mod_name(mid))//'] nid= ',prid,
     $      ' '//trim(llogs)
      else
         write(str,'(I3)') mid
         write(*,*) ' ['//trim(mntr_name)//'] ',
     $   ' WARNING: module'//trim(str)//' not registered;'
         write(*,*) 'Log body: nid= ',prid,' '//trim(llogs)
      endif

      return
      end subroutine
!=======================================================================
!> @brief Write log message adding single integer
!! @ingroup monitor
!! @param[in] mid       module id
!! @param[in] priority  log priority
!! @param[in] logs      log body
!! @param[in] ivar      integer variable
      subroutine mntr_logi(mid,priority,logs,ivar)
      implicit none

      ! argument list
      integer mid,priority,ivar
      character*(*) logs

      ! local variables
      character*10 str
!-----------------------------------------------------------------------
      write(str,'(I8)') ivar
      call mntr_log(mid,priority,trim(logs)//' '//trim(str))

      return
      end subroutine
!=======================================================================
!> @brief Write log message adding single real
!! @ingroup monitor
!! @param[in] mid       module id
!! @param[in] priority  log priority
!! @param[in] logs      log body
!! @param[in] rvar      real variable
      subroutine mntr_logr(mid,priority,logs,rvar)
      implicit none

      ! argument list
      integer mid,priority
      character*(*) logs
      real rvar

      ! local variables
      character*20 str
!-----------------------------------------------------------------------
      write(str,'(E15.8)') rvar
      call mntr_log(mid,priority,trim(logs)//' '//trim(str))

      return
      end subroutine
!=======================================================================
!> @brief Write log message adding single logical
!! @ingroup monitor
!! @param[in] mid       module id
!! @param[in] priority  log priority
!! @param[in] logs      log body
!! @param[in] lvar      logical variable
      subroutine mntr_logl(mid,priority,logs,lvar)
      implicit none

      ! argument list
      integer mid,priority
      character*(*) logs
      logical lvar

      ! local variables
      character*2 str
!-----------------------------------------------------------------------
      write(str,'(L2)') lvar
      call mntr_log(mid,priority,trim(logs)//' '//trim(str))

      return
      end subroutine
!=======================================================================
!> @brief Write warning message
!! @ingroup monitor
!! @param[in] mid       module id
!! @param[in] logs      log body
      subroutine mntr_warn(mid,logs)
      implicit none

      include 'FRAMELP'

      ! argument list
      integer mid,priority
      character*(*) logs
!-----------------------------------------------------------------------
      call mntr_log(mid,lp_inf,'WARNING: '//logs)
      return
      end subroutine
!=======================================================================
!> @brief Write error message
!! @ingroup monitor
!! @param[in] mid       module id
!! @param[in] logs      log body
      subroutine mntr_error(mid,logs)
      implicit none

      include 'FRAMELP'

      ! argument list
      integer mid
      character*(*) logs
!-----------------------------------------------------------------------
      call mntr_log(mid,lp_err,'ERROR: '//logs)
      return
      end subroutine
!=======================================================================
!> @brief Abort simulation
!! @ingroup monitor
!! @param[in] mid       module id
!! @param[in] logs      log body
      subroutine mntr_abort(mid,logs)
      implicit none

      include 'FRAMELP'

      ! argument list
      integer mid
      character*(*) logs
!-----------------------------------------------------------------------
      call mntr_log(mid,lp_err,'ABORT: '//logs)
      call exitt
      return
      end subroutine
!=======================================================================
!> @brief Abort simulation
!! @ingroup monitor
!! @param[in] mid       module id
!! @param[in] ierr      error flag
!! @param[in] logs      log body
      subroutine mntr_check_abort(mid,ierr,logs)
      implicit none

      include 'FRAMELP'

      ! argument list
      integer mid,ierr
      character*(*) logs

      ! local variables
      integer itest
      character*5 str
      ! functions
      integer iglmax
!-----------------------------------------------------------------------
      itest = iglmax(ierr,1)

      if (itest.gt.0) then
         write(str,'(I3)') itest
         call mntr_log(mid,lp_err,
     $         'ABORT: '//trim(logs)//' ierr='//trim(str))
         call exitt
      endif
      return
      end subroutine
!=======================================================================
!> @brief Print registered modules showing tree structure
!! @ingroup monitor
      subroutine mntr_mod_summary_print()
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'MNTRLOGD'

      ! local variables
      integer il, stride
      parameter (stride=4)
      integer olist(2,mntr_id_max), ierr
      character*25 ftm
      character*3 str
!-----------------------------------------------------------------------
      call mntr_log(mntr_id,lp_prd,
     $         'Summary of registered modules')

      if (nid.eq.mntr_pid0) then
         ! get ordered list
         call mntr_mod_get_olist(olist, ierr)


         if(ierr.eq.0.and.mntr_lp_def.le.lp_prd) then
            do il=1,mntr_mod_num
               write(str,'(I3)') stride*(olist(2,il))
               ftm = '('//trim(str)//'X,"[",A,"] : ",A)'
               write(*,ftm) mntr_mod_name(olist(1,il)),
     $                mntr_mod_dscr(olist(1,il))
            enddo
         endif
      endif

      return
      end subroutine
!=======================================================================
!> @brief Provide ordered list of registered modules for printing.
!! @ingroup monitor
!! @param[out]   olist    ordered list
!! @param[out]   ierr     error flag
      subroutine mntr_mod_get_olist(olist,ierr)
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'MNTRLOGD'

      ! argument list
      integer olist(2,mntr_id_max), ierr

      ! local variables
      integer ind(mntr_id_max), level, parent, ipos
      integer slist(2,mntr_id_max), itmp1(2)
      integer npos, key
      integer il, jl
      integer istart, in, itest
!-----------------------------------------------------------------------
      ierr = 0

      ! sort module index array
      ! copy data removing possible empty slots
      npos=0
      do il=1,mntr_mod_mpos
         if (mntr_mod_id(il).ge.0) then
            npos = npos + 1
            slist(1,npos) = mntr_mod_id(il)
            slist(2,npos) = il
         endif
      enddo
      if(npos.ne.mntr_mod_num) then
         ierr = 1
         call mntr_log_local(mntr_id,lp_inf,
     $         'Inconsistent module number; return',mntr_pid0)
         return
      endif

      ! sort with respect to parent id
      key = 1
      call ituple_sort(slist,2,npos,key,1,ind,itmp1)

      ! sort within children of single parent with respect to children id
      istart = 1
      itest = slist(1,istart)
      do il=1,npos
         if(itest.ne.slist(1,il).or.il.eq.npos) then
           if (il.eq.npos.and.itest.eq.slist(1,il)) then
              jl = npos + 1
           else
              jl = il
           endif
           in = jl - istart
           if (itest.eq.0.and.in.ne.1) then
              call mntr_log_local(mntr_id,lp_inf,
     $         'Must be single root of the graph; return',mntr_pid0)
              ierr = 2
              return
           endif
           if (in.gt.1) then
              key = 2
              call ituple_sort(slist(1,istart),2,in,key,1,ind,itmp1)
           endif
           if (il.ne.npos) then
              itest = slist(1,il)
              istart = il
           endif
         endif
      enddo

      parent = 0
      level = 0
      ipos = 1
      call mntr_build_ord_list(olist,slist,npos,ipos,parent,level)

      return
      end subroutine
!=======================================================================
!> @brief Build ordered list reflecting graph structure
!! @ingroup monitor
!! @param[out]   olist    ordered list
!! @param[inout] slist    list sorted with respect to parent
!! @param[in]    nlist    lists length
!! @param[inout] npos     position in olist array
!! @param[in]    parent   parent id
!! @param[in]    level    parent level
      recursive subroutine mntr_build_ord_list(olist,slist,nlist,npos,
     $     parent,level)
      implicit none

      ! argument list
      integer nlist, npos, parent, level
      integer olist(2,nlist),slist(2,nlist)

      ! local variables
      integer il
      integer lparent, llevel
!-----------------------------------------------------------------------
      llevel = level + 1
      do il=1, nlist
         if (slist(1,il).eq.parent) then
            slist(1,il) = - parent
            lparent = slist(2,il)
            olist(1,npos) = lparent
            olist(2,npos) = llevel
            npos = npos +1
            call mntr_build_ord_list(olist,slist,nlist,npos,lparent,
     $           llevel)
         endif
      enddo

      return
      end subroutine
!=======================================================================



!> @file io_tools_block.f
!! @ingroup io_tools
!! @brief Block data to initialise common block for I/O routines
!! @details Following Nek5000 standard I keep block data in seaprate file.
!! The minimal unit id has been choosen to not interact with file ids
!! hard-coded in Nek5000.
!! @author Adam Peplinski
!! @date Mar 7, 2016
!=======================================================================
      block data io_common_init
      include 'IOTOOLD'

      data io_iunit_min/200/
      data io_iunit_max/200/
      end



!> @file io_tools.f
!! @ingroup io_tools
!! @brief Set of I/O related tools for KTH modules
!! @author Adam Peplinski
!! @date Mar 7, 2016
!=======================================================================
!> @brief Register io tool module
!! @ingroup io_tools
!! @note This routine should be called in frame_usr_register
      subroutine io_register()
      implicit none

      include 'FRAMELP'
      include 'IOTOOLD'

      ! local variables
      integer lpmid
!-----------------------------------------------------------------------
      ! check if the current module was already registered
      call mntr_mod_is_name_reg(lpmid,io_name)
      if (lpmid.gt.0) then
         call mntr_warn(lpmid,
     $        'module ['//trim(io_name)//'] already registered')
         return
      endif

      ! find parent module
      call mntr_mod_is_name_reg(lpmid,'FRAME')
      if (lpmid.le.0) then
         lpmid = 1
         call mntr_abort(lpmid,
     $        'Parent module ['//'FRAME'//'] not registered')
      endif

      ! register module
      call mntr_mod_reg(io_id,lpmid,io_name,'I/O TOOLS')

      return
      end subroutine
!=======================================================================
!> @brief Get free file unit number and store max unit value
!! @ingroup io_tools
!! @param[out] iunit     file unit
!! @param[out] ierr      error mark
!! @see io_file_close
      subroutine io_file_freeid(iunit, ierr)
      implicit none

      include 'FRAMELP'
      include 'IOTOOLD'

      ! argument list
      integer iunit
      integer ierr

      ! local variables
      logical ifcnnd            ! is unit connected
!-----------------------------------------------------------------------
      ! initialise variables
      ierr=0
      iunit = io_iunit_min

      do
         inquire(unit=iunit,opened=ifcnnd,iostat=ierr)
         if(ifcnnd) then
            iunit = iunit +1
         else
            exit
         endif
      enddo

      if (iunit.gt.io_iunit_max) io_iunit_max = iunit

      return
      end subroutine
!=======================================================================
!> @brief Close all opened files up to sotred max unit numer
!! @ingroup io_tools
!! @see io_file_freeid
      subroutine io_file_close()
      implicit none

      include 'FRAMELP'
      include 'IOTOOLD'

      ! local variables
      integer iunit, ierr
      logical ifcnnd            ! is unit connected
!-----------------------------------------------------------------------
      do iunit = io_iunit_min, io_iunit_max
         inquire(unit=iunit,opened=ifcnnd,iostat=ierr)
         if(ifcnnd) close(iunit)
      enddo
      io_iunit_max = io_iunit_min

      return
      end subroutine
!=======================================================================
!> @brief Generate file name according to nek rulles without opening the file
!! @details It is a modified version of @ref mfo_open_files from prepost.f but
!! without equivalence and file opening part. I split file name generation
!! and file opening as different tools can require this.
!! @ingroup io_tools
!! @param[out]  fname     file name
!! @param[in]   bname     base name
!! @param[in]   prefix    prefix
!! @param[out]  ierr      error mark
      subroutine io_mfo_fname(fname,bname,prefix,ierr)
      implicit none

      include 'SIZE'
      include 'INPUT'           ! IFREGUO, IFMPIIO
      include 'RESTART'         ! NFILEO
      include 'FRAMELP'
      include 'IOTOOLD'


      ! argument list
      character*132  fname, bname
      character*3 prefix
      integer ierr

      ! local variables
      integer ndigit, itmp
      real rfileo

      character*(*)  six
      parameter(six='??????')
!-----------------------------------------------------------------------
      ! initialise variables
      ierr = 0
      fname = ''

      ! numbe or IO nodes
      if (IFMPIIO) then
        rfileo = 1
      else
        rfileo = NFILEO
      endif
      ndigit = log10(rfileo) + 1

      ! Add directory
      if (ifdiro) fname = 'A'//six(1:ndigit)//'/'

      ! Add prefix
      if (prefix(1:1).ne.' '.and.prefix(2:2).ne.' '
     $    .and.prefix(3:3).ne.' ')
     $     fname = trim(fname)//trim(adjustl(prefix))

      ! Add SESSION
      fname = trim(fname)//trim(adjustl(bname))

      if (IFREGUO) fname = trim(fname)//'_reg'

      ! test string length
      itmp = len_trim(fname)
      if (itmp.eq.0) then
         call mntr_error(io_id,'io_mfo_fname; zero lenght fname.')
         ierr = 1
         return
      elseif ((itmp+ndigit+2+5).gt.132) then
         call mntr_error(io_id,'io_mfo_fname; fname too long.')
         ierr = 2
         return
      endif

      ! Add file-id holder and .f appendix
      fname = trim(fname)//six(1:ndigit)//'.f'

      return
      end subroutine
!=======================================================================
!> @brief Open field file
!! @details This routine opens the file (serial or parallel depending on
!!    parmeter set by @ref io_init) using Nek5000 C routines. I need it
!!    for a number of tools writing restart files that do not directly
!!    stick to the numbering scheme used in @ref mfo_open_files.
!! @ingroup io_tools
!! @param[in]   hname      file name
!! @param[out]  ierr       error mark
      subroutine io_mbyte_open(hname,ierr)
      implicit none

      include 'SIZE'            ! NID
      include 'INPUT'           ! ifmpiio
      include 'RESTART'         ! fid0, pid0, ifh_mbyte
      include 'FRAMELP'
      include 'IOTOOLD'

      ! argumnt list
      integer fid, ierr
      character*132 hname

      ! local variables
      character*132 fname
      integer itmp
!-----------------------------------------------------------------------
      ! initialise variables
      ierr = 0
      ! work on local copy
      fname = trim(adjustl(hname))

      ! test string length
      itmp = len_trim(fname)
      if (itmp.eq.0) then
         call mntr_error(io_id,'io_mbyte_open; zero lenght fname.')
         ierr = 1
         return
      endif

      ! add file number
      call addfid(fname,fid0)

      call mntr_log(io_id,lp_ess,'Opening file: '//trim(fname))
      if(ifmpiio) then
        call byte_open_mpi(fname,ifh_mbyte,.false.,ierr)
      else
        ! add ending character; required by C
        fname = trim(fname)//CHAR(0)
        call byte_open(fname,ierr)
      endif

      return
      end subroutine
!=======================================================================
!> @brief Close field file
!! @details This routine closes the file (serial or parallel depending on
!!    parmeter set by @ref io_init) using Nek5000 C routines.
!! @ingroup io_tools
!! @param[out]  ierr       error mark
      subroutine io_mbyte_close(ierr)
      implicit none

      include 'SIZE'            ! NID
      include 'INPUT'           ! ifmpiio
      include 'RESTART'         ! pid0, ifh_mbyte

      ! argumnt list
      integer ierr

      ! local variables
      character*132 fname
      integer itmp
!-----------------------------------------------------------------------
      ! initialise variables
      ierr = 0

      ! close the file
      if (nid.eq.pid0) then
         if(ifmpiio) then
           call byte_close_mpi(ifh_mbyte,ierr)
         else
           call byte_close(ierr)
         endif
      endif

      return
      end subroutine
!=======================================================================
!> @brief Write single vector to the file
!! @details This routine is based on @ref mfo_outfld but can be used for
!!    writing 2D sections of 3D simulation.
!! @ingroup io_tools
!! @param[inout] offs               offset of global vector beginning
!! @param[in]    lvx,lvy,lvz        vector to write
!! @param[in]    lnx,lny,lnz        element dimensions
!! @param[in]    lnel               local number of filed elements
!! @param[in]    lnelg              global number of filed elements
!! @param[in]    lndim              written domain dimension
!! @remark This routine uses global scratch space \a SCRUZ.
      subroutine io_mfov(offs,lvx,lvy,lvz,lnx,lny,lnz,
     $           lnel,lnelg,lndim)
      implicit none

      include 'SIZE'
      include 'INPUT'
      include 'RESTART'
      include 'FRAMELP'
      include 'IOTOOLD'

      ! argumnt list
      integer*8 offs
      integer lnx,lny,lnz,lnel,lnelg,lndim
      real lvx(lnx,lny,lnz,lnel), lvy(lnx,lny,lnz,lnel)
      real lvz(lnx,lny,lnz,lnel)

      ! local variables
      integer*8 loffs
      integer il, ik, itmp

      real rvx(lxo*lxo*(1 + (ldim-2)*(lxo-1))*lelt),
     $     rvy(lxo*lxo*(1 + (ldim-2)*(lxo-1))*lelt),
     $     rvz(lxo*lxo*(1 + (ldim-2)*(lxo-1))*lelt)
      common /SCRUZ/ rvx, rvy, rvz
!-----------------------------------------------------------------------
      if (ifreguo) then
         ! check size of mapping space
         if (nrg.gt.lxo) then
            call mntr_warn(io_id,
     $          'io_mfov; nrg too large, reset to lxo!')
            nrg = lxo
         endif

         ! map to regular mesh
         ! this code works with square element only
         itmp = nrg**lndim
         if (lndim.eq.2) then
            ik=1
            do il=1,lnel
               call map2reg_2di_e(rvx(ik),nrg,lvx(1,1,1,il),lnx)
               ik = ik + itmp
            enddo
            ik=1
            do il=1,lnel
               call map2reg_2di_e(rvy(ik),nrg,lvy(1,1,1,il),lnx)
               ik = ik + itmp
            enddo
         else
            ik = 1
            do il=1,lnel
               call map2reg_3di_e(rvx(ik),nrg,lvx(1,1,1,il),lnx)
               ik = ik + itmp
            enddo
            ik = 1
            do il=1,lnel
               call map2reg_3di_e(rvy(ik),nrg,lvy(1,1,1,il),lnx)
               ik = ik + itmp
            enddo
            ik = 1
            do il=1,lnel
               call map2reg_3di_e(rvz(ik),nrg,lvz(1,1,1,il),lnx)
               ik = ik + itmp
            enddo
         endif

         ! shift offset taking onto account elements on processes with smaller id
         itmp = 1 + (lndim-2)*(nrg-1)
         ! to ensure proper integer prolongation
         loffs = offs + int(nelB,8)*int(lndim*wdsizo*nrg*nrg*itmp,8)
         call byte_set_view(loffs,ifh_mbyte)

         ! write vector
         call mfo_outv(rvx,rvy,rvz,lnel,nrg,nrg,itmp)

         ! update offset
         offs = offs + int(lnelg,8)*int(lndim*wdsizo*nrg*nrg*itmp,8)
      else
         ! shift offset taking onto account elements on processes with smaller id
         ! to ensure proper integer prolongation
         loffs = offs + int(nelB,8)*int(lndim*wdsizo*lnx*lny*lnz,8)
         call byte_set_view(loffs,ifh_mbyte)

         ! write vector
         call mfo_outv(lvx,lvy,lvz,lnel,lnx,lny,lnz)

         ! update offset
         offs = offs + int(lnelg,8)*int(lndim*wdsizo*lnx*lny*lnz,8)
      endif

      return
      end subroutine
!=======================================================================
!> @brief Write single scalar to the file
!! @details This routine is based on @ref mfo_outfld but can be used for
!!    writing 2D sections of 3D simulation.
!! @ingroup io_tools
!! @param[inout] offs               offset of global vector beginning
!! @param[in]    lvs                scalar to write
!! @param[in]    lnx,lny,lnz        element dimensions
!! @param[in]    lnel               local number of field elements
!! @param[in]    lnelg              global number of filed elements
!! @param[in]    lndim              written domain dimension
!! @remark This routine uses global scratch space \a SCRUZ.
      subroutine io_mfos(offs,lvs,lnx,lny,lnz,lnel,lnelg,lndim)
      implicit none

      include 'SIZE'
      include 'INPUT'
      include 'RESTART'
      include 'FRAMELP'
      include 'IOTOOLD'

      ! argumnt list
      integer*8 offs
      integer lnx,lny,lnz,lnel,lnelg,lndim
      real lvs(lnx,lny,lnz,lnel)

      ! local variables
      integer*8 loffs
      integer il, ik, itmp

      real rvs(lxo*lxo*(1 + (ldim-2)*(lxo-1))*lelt)
      common /SCRUZ/ rvs
!-----------------------------------------------------------------------
      if (ifreguo) then
         ! check size of mapping space
         if (nrg.gt.lxo) then
            call mntr_warn(io_id,
     $          'io_mfos; nrg too large, reset to lxo!')
            nrg = lxo
         endif

         ! map to regular mesh
         ! this code works with square element only
         itmp = nrg**lndim
         if (lndim.eq.2) then
            ik=1
            do il=1,lnel
               call map2reg_2di_e(rvs(ik),nrg,lvs(1,1,1,il),lnx)
               ik = ik + itmp
            enddo
         else
            ik = 1
            do il=1,lnel
               call map2reg_3di_e(rvs(ik),nrg,lvs(1,1,1,il),lnx)
               ik = ik + itmp
            enddo
         endif

         ! shift offset taking onto account elements on processes with smaller id
         itmp = 1 + (lndim-2)*(nrg-1)
         ! to ensure proper integer prolongation
         loffs = offs + int(nelB,8)*int(wdsizo*nrg*nrg*itmp,8)
         call byte_set_view(loffs,ifh_mbyte)

         ! write vector
         call mfo_outs(rvs,lnel,nrg,nrg,itmp)

         ! update offset
         offs = offs + int(lnelg,8)*int(wdsizo*nrg*nrg*itmp,8)
      else
         ! shift offset taking onto account elements on processes with smaller id
         ! to ensure proper integer prolongation
         loffs = offs + int(nelB,8)*int(wdsizo*lnx*lny*lnz,8)
         call byte_set_view(loffs,ifh_mbyte)

         ! write vector
         call mfo_outs(lvs,lnel,lnx,lny,lnz)

         ! update offset
         offs = offs + int(lnelg,8)*int(wdsizo*lnx*lny*lnz,8)
      endif

      return
      end subroutine
!=======================================================================
!> @brief Read vector filed from the file
!! @details This is version of @ref mfi_getv that does not perform
!!    interpolation and allows to specify element size.
!! @param[inout] offs         offset of global vector beginning
!! @param[out]   uf, vf, wf   vector field compinents
!! @param[in]    lnx,lny,lnz  element size
!! @param[in]    lnel         number of elements
!! @param[in]    ifskip       reading flag (for non-mpi formats)
!! @remarks This routine uses global scratch space \a VRTHOV and \a SCRNS
      subroutine io_mfiv(offs,uf,vf,wf,lnx,lny,lnz,lnel,ifskip)
      implicit none
      include 'SIZE'
      include 'INPUT'
      include 'PARALLEL'
      include 'RESTART'
      include 'FRAMELP'
      include 'IOTOOLD'

      ! argument list
      integer*8 offs
      integer lnx,lny,lnz,lnel
      real uf(lnx*lny*lnz,lnel),vf(lnx*lny*lnz,lnel)
      real wf(lnx*lny*lnz,lnel)
      logical ifskip

      ! local variables
      integer lndim, nxyzr, nxyzw, nxyzv, mlen
      integer num_recv, num_avail, nread, nelrr
      integer el, il, kl, ll, ierr
      integer ei, eg, jnid, jeln
      integer msg_id(lelt)
      integer*8 i8tmp

      ! read buffer
      integer lrbs
      parameter(lrbs=20*lx1*ly1*lz1*lelt)
      real*4 w2(lrbs)
      common /vrthov/ w2

      ! communication buffer
      integer lwk
      parameter (lwk = 14*lx1*ly1*lz1*lelt)
      real*4 wk(lwk)
      common /SCRNS/ wk

      ! functions
      integer irecv, iglmax
!-----------------------------------------------------------------------
      call nekgsync() ! clear outstanding message queues.

      ! check element size
      if ((nxr.ne.lnx).or.(nyr.ne.lny).or.(nzr.ne.lnz)) then
         call mntr_abort(io_id,'io_mfiv, wrong element size')
      endif

      if (lnz.gt.1) then
         lndim = 3
      else
         lndim = 2
      endif

      nxyzr  = lndim*lnx*lny*lnz   ! element size
      mlen   = nxyzr*wdsizr  ! message length
      if (wdsizr.eq.8) then
         nxyzw = 2*nxyzr
      else
         nxyzw = nxyzr
      endif

      ! shift offset
      i8tmp = offs + int(nelBr,8)*int(mlen,8)
      call byte_set_view(i8tmp,ifh_mbyte)

      ! check message buffer
      num_recv  = mlen
      num_avail = lwk*4
      call lim_chk(num_recv,num_avail,'     ','     ','io_mfiv a')

      ! setup read buffer
      if (nid.eq.pid0r) then
         i8tmp = int(nxyzw,8)*int(nelr,8)
         nread = i8tmp/int(lrbs,8)
         if (mod(i8tmp,int(lrbs,8)).ne.0) nread = nread + 1
         if(ifmpiio) nread = iglmax(nread,1) ! needed because of collective read
         nelrr = nelr/nread
      endif
      call bcast(nelrr,4)
      call lim_chk(nxyzw*nelrr,lrbs,'     ','     ','io_mfiv b')

      ! reset error flag
      ierr = 0

      if (ifskip) then ! just read deata and do not use it (avoid communication)

         if (nid.eq.pid0r) then ! only i/o nodes will read
            ! read blocks of size nelrr
            kl = 0
            do il = 1,nread
               if (il.eq.nread) then ! clean-up
                  nelrr = nelr - (nread-1)*nelrr
                  if (nelrr.lt.0) nelrr = 0
               endif

               if (ierr.eq.0) then
                  if (ifmpiio) then
                    call byte_read_mpi(w2,nxyzw*nelrr,-1,ifh_mbyte,ierr)
                  else
                    call byte_read (w2,nxyzw*nelrr,ierr)
                  endif
               endif
            enddo
         endif

         call nekgsync()

      else   ! read and use data
         ! pre-post recieves
         if (np.gt.1) then
            ll = 1
            do el=1,nelt
               msg_id(el) = irecv(el,wk(ll),mlen)
               ll = ll+nxyzw
            enddo
         endif

         if (nid.eq.pid0r.and.np.gt.1) then ! only i/o nodes will read
            ! read blocks of size nelrr
            kl = 0
            do il = 1,nread
               if (il.eq.nread) then ! clean-up
                  nelrr = nelr - (nread-1)*nelrr
                  if (nelrr.lt.0) nelrr = 0
               endif

               if (ierr.eq.0) then
                  if (ifmpiio) then
                    call byte_read_mpi(w2,nxyzw*nelrr,-1,ifh_mbyte,ierr)
                  else
                    call byte_read (w2,nxyzw*nelrr,ierr)
                  endif
               endif

               ! distribute data across target processors
               ll = 1
               do el = kl+1,kl+nelrr
                  jnid = gllnid(er(el))                ! where is er(e) now?
                  jeln = gllel(er(el))
                  if(ierr.ne.0) call rzero(w2(ll),mlen)
                  call csend(jeln,w2(ll),mlen,jnid,0)  ! blocking send
                  ll = ll+nxyzw
               enddo
               kl = kl + nelrr
            enddo
         elseif (np.eq.1) then
            if (ifmpiio) then
               call byte_read_mpi(wk,nxyzw*nelr,-1,ifh_mbyte,ierr)
            else
               call byte_read(wk,nxyzw*nelr,ierr)
            endif
         endif

         ! distinguish between vector lengths
         nxyzv = lnx*lny*lnz
         if (wdsizr.eq.8) then
            nxyzw = 2*nxyzv
         else
            nxyzw = nxyzv
         endif

         ll = 1
         do el=1,nelt
            if (np.gt.1) then
               call msgwait(msg_id(el))
               ei = el
            elseif(np.eq.1) then
              ei = er(el)
            endif
            if (if_byte_sw) then
               if (wdsizr.eq.8) then
                  call byte_reverse8(wk(ll),nxyzr*2,ierr)
               else
                  call byte_reverse(wk(ll),nxyzr,ierr)
               endif
            endif
            ! copy data
            if (wdsizr.eq.4) then
               call copy4r(uf(1,ei),wk(ll),nxyzv)
               call copy4r(vf(1,ei),wk(ll + nxyzw),nxyzv)
               if (lndim.eq.3)
     $             call copy4r(wf(1,ei),wk(ll + 2*nxyzw),nxyzv)
            else
               call copy(uf(1,ei),wk(ll),nxyzv)
               call copy(vf(1,ei),wk(ll + nxyzw),nxyzv)
               if (lndim.eq.3)
     $             call copy(wf(1,ei),wk(ll + 2*nxyzw),nxyzv)
            endif
            ll = ll+ldim*nxyzw
         enddo

      endif

      ! update offset
      offs = offs + int(nelgr,8)*int(mlen,8)

      call err_chk(ierr,'Error reading restart data,in io_mfiv.$')
      return
      end subroutine
!=======================================================================
!> @brief Read scalar filed from the file
!! @details This is version of @ref mfi_gets that does not perform
!!    interpolation and allows to specify element size.
!! @ingroup io_tools
!! @param[inout] offs         offset of global vector beginning
!! @param[out]   uf           scalar field
!! @param[in]    lnx,lny,lnz  element size
!! @param[in]    lnel         number of elements
!! @param[in]    ifskip       reading flag (for non-mpi formats)
!! @remarks This routine uses global scratch space \a VRTHOV and \a SCRNS
      subroutine io_mfis(offs,uf,lnx,lny,lnz,lnel,ifskip)
      implicit none
      include 'SIZE'
      include 'INPUT'
      include 'PARALLEL'
      include 'RESTART'
      include 'FRAMELP'
      include 'IOTOOLD'

      ! argument list
      integer*8 offs
      integer lnx,lny,lnz,lnel
      real uf(lnx*lny*lnz,lnel)
      logical ifskip

      ! local variables
      integer nxyzr, nxyzw, mlen
      integer num_recv, num_avail, nread, nelrr
      integer el, il, kl, ll, ierr
      integer ei, eg, jnid, jeln
      integer msg_id(lelt)
      integer*8 i8tmp

      ! read buffer
      integer lrbs
      parameter(lrbs=20*lx1*ly1*lz1*lelt)
      real*4 w2(lrbs)
      common /vrthov/ w2

      ! communication buffer
      integer lwk
      parameter (lwk = 14*lx1*ly1*lz1*lelt)
      real*4 wk(lwk)
      common /SCRNS/ wk

      ! functions
      integer irecv, iglmax
!-----------------------------------------------------------------------
      call nekgsync() ! clear outstanding message queues.

      ! check element size
      if ((nxr.ne.lnx).or.(nyr.ne.lny).or.(nzr.ne.lnz)) then
         call mntr_abort(io_id,'io_mfis, wrong element size')
      endif

      nxyzr  = lnx*lny*lnz   ! element size
      mlen   = nxyzr*wdsizr  ! message length
      if (wdsizr.eq.8) then
         nxyzw = 2*nxyzr
      else
         nxyzw = nxyzr
      endif

      ! shift offset
      i8tmp = offs + int(nelBr,8)*int(mlen,8)
      call byte_set_view(i8tmp,ifh_mbyte)

      ! check message buffer
      num_recv  = mlen
      num_avail = lwk*4
      call lim_chk(num_recv,num_avail,'     ','     ','io_mfis a')

      ! setup read buffer
      if (nid.eq.pid0r) then
         i8tmp = int(nxyzw,8)*int(nelr,8)
         nread = i8tmp/int(lrbs,8)
         if (mod(i8tmp,int(lrbs,8)).ne.0) nread = nread + 1
         if(ifmpiio) nread = iglmax(nread,1) ! needed because of collective read
         nelrr = nelr/nread
      endif
      call bcast(nelrr,4)
      call lim_chk(nxyzw*nelrr,lrbs,'     ','     ','io_mfis b')

      ! reset error flag
      ierr = 0

      if (ifskip) then ! just read deata and do not use it (avoid communication)

         if (nid.eq.pid0r) then ! only i/o nodes will read
            ! read blocks of size nelrr
            kl = 0
            do il = 1,nread
               if (il.eq.nread) then ! clean-up
                  nelrr = nelr - (nread-1)*nelrr
                  if (nelrr.lt.0) nelrr = 0
               endif

               if (ierr.eq.0) then
                  if (ifmpiio) then
                    call byte_read_mpi(w2,nxyzw*nelrr,-1,ifh_mbyte,ierr)
                  else
                    call byte_read (w2,nxyzw*nelrr,ierr)
                  endif
               endif
            enddo
         endif

         call nekgsync()

      else   ! read and use data
         ! pre-post recieves
         if (np.gt.1) then
            ll = 1
            do el=1,nelt
               msg_id(el) = irecv(el,wk(ll),mlen)
               ll = ll+nxyzw
            enddo
         endif

         if (nid.eq.pid0r.and.np.gt.1) then ! only i/o nodes will read
            ! read blocks of size nelrr
            kl = 0
            do il = 1,nread
               if (il.eq.nread) then ! clean-up
                  nelrr = nelr - (nread-1)*nelrr
                  if (nelrr.lt.0) nelrr = 0
               endif

               if (ierr.eq.0) then
                  if (ifmpiio) then
                    call byte_read_mpi(w2,nxyzw*nelrr,-1,ifh_mbyte,ierr)
                  else
                    call byte_read (w2,nxyzw*nelrr,ierr)
                  endif
               endif

               ! distribute data across target processors
               ll = 1
               do el = kl+1,kl+nelrr
                  jnid = gllnid(er(el))                ! where is er(e) now?
                  jeln = gllel(er(el))
                  if(ierr.ne.0) call rzero(w2(ll),mlen)
                  call csend(jeln,w2(ll),mlen,jnid,0)  ! blocking send
                  ll = ll+nxyzw
               enddo
               kl = kl + nelrr
            enddo
         elseif (np.eq.1) then
            if (ifmpiio) then
               call byte_read_mpi(wk,nxyzw*nelr,-1,ifh_mbyte,ierr)
            else
               call byte_read(wk,nxyzw*nelr,ierr)
            endif
         endif

         ll = 1
         do el=1,nelt
            if (np.gt.1) then
               call msgwait(msg_id(el))
               ei = el
            elseif(np.eq.1) then
               ei = er(el)
            endif
            if (if_byte_sw) then
               if (wdsizr.eq.8) then
                  call byte_reverse8(wk(ll),nxyzw,ierr)
               else
                  call byte_reverse(wk(ll),nxyzw,ierr)
               endif
            endif
            ! copy data
            if (wdsizr.eq.4) then
               call copy4r(uf(1,ei),wk(ll),nxyzr)
            else
               call copy  (uf(1,ei),wk(ll),nxyzr)
            endif
            ll = ll+nxyzw
         enddo

      endif

      ! update offset
      offs = offs + int(nelgr,8)*int(mlen,8)

      call err_chk(ierr,'Error reading restart data,in io_mfis.$')
      return
      end subroutine
!=======================================================================



!> @file frame.f
!! @ingroup frame
!! @brief Set of routines for framework operation
!! @author Adam Peplinski
!! @date 13 Oct 2017
!=======================================================================
!> @brief Start framework
!! @ingroup frame
!! @note This routine requires \a frame_usr_register and
!!    \a frame_usr_init to be defined in \a setup.usr
      subroutine frame_start
      implicit none

      include 'SIZE'
      include 'PARALLEL'
      include 'FRAMELP'

      ! local variables
      integer log_thr, slen, ierr
      character*18 log_cval
!-----------------------------------------------------------------------
      ! check logging threshold
      if (nid.eq.0) then
         call getenv('FRAMELOGL',log_cval)
         slen = len_trim(log_cval)
         if (slen.gt.0) then
            read(log_cval,'(I2)',iostat=ierr) log_thr
            if (ierr.gt.0) log_thr = lp_inf
         else
            log_thr = lp_inf
         endif
      endif

      call bcast(log_thr,isize)

      ! register backbone modules na runtime parameters
      call mntr_register_mod(log_thr)
      call rprm_register
      call mntr_register_par

      ! regisred user specified moduels
      call frame_usr_register

      ! get runtime parameters from Nek5000 dictionary
      call rprm_dict_get
      call mntr_init
      call rprm_init

      ! initialise user specified modules
      call frame_usr_init

      return
      end subroutine
!=======================================================================
!> @brief Simulataion monitoring
!! @ingroup frame
      subroutine frame_monitor
      implicit none

      include 'SIZE'
      include 'FRAMELP'

!-----------------------------------------------------------------------
      ! monitor simulation wall clock
      call mntr_wclock

      ! place for other monitoring operations

      return
      end subroutine
!=======================================================================
!> @brief Finalise framework
!! @ingroup frame
      subroutine frame_end
      implicit none

      include 'SIZE'
      include 'FRAMELP'

!-----------------------------------------------------------------------
      ! finalilse user specified modules
      call frame_usr_end

      ! close all opened files
      call io_file_close

      ! place for timers summary
      call mntr_tmr_summary_print()

      return
      end subroutine
!=======================================================================
!> @brief Specify master node id
!! @ingroup frame
!! @return frame_get_master
!! @note This routine requires \a frame_usr_end to be defined in
!!    \a setup.usr
      integer function frame_get_master()
      implicit none
!-----------------------------------------------------------------------
      frame_get_master = 0

      return
      end function
!=======================================================================




!> @file chkpt_mstp.f
!! @ingroup chkpoint_mstep
!! @brief Set of multi-file checkpoint routines for DNS, MHD and
!!    perturbation simulations
!=======================================================================
!> @brief Register multi step checkpointing module
!! @ingroup chkpoint_mstep
      subroutine chkpts_register()
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'CHKPOINTD'
      include 'CHKPTMSTPD'

      ! local variables
      integer lpmid
!-----------------------------------------------------------------------
      ! check if the current module was already registered
      call mntr_mod_is_name_reg(lpmid,chpm_name)
      if (lpmid.gt.0) then
         call mntr_warn(lpmid,
     $        'module ['//trim(chpm_name)//'] already registered')
         return
      endif

      ! find parent module
      call mntr_mod_is_name_reg(lpmid,chpt_name)
      if (lpmid.le.0) then
        lpmid = 1
        call mntr_abort(lpmid,
     $   'Parent ['//trim(chpt_name)//'] module not registered')
      endif

      ! register module
      call mntr_mod_reg(chpm_id,lpmid,chpm_name,
     $         'Multi-file checkpointing')

      ! register timers
      call mntr_tmr_is_name_reg(lpmid,'CHP_TOT')
      call mntr_tmr_reg(chpm_tread_id,lpmid,chpm_id,
     $      'CHP_READ','Checkpointing reading time',.true.)

      call mntr_tmr_reg(chpm_twrite_id,lpmid,chpm_id,
     $      'CHP_WRITE','Checkpointing writing time',.true.)

      ! adjust step delay
      call mntr_set_step_delay(chpm_snmax)

      return
      end subroutine
!=======================================================================
!> @brief Initialise multi-file checkpoint routines
!! @ingroup chkpoint_mstep
!! @note This interface is defined in @ref chkpt_main
      subroutine chkpts_init
      implicit none

      include 'SIZE'            ! NID, NPERT
      include 'TSTEP'           ! ISTEP, NSTEPS
      include 'INPUT'           ! IFPERT, PARAM
      include 'FRAMELP'
      include 'CHKPOINTD'
      include 'CHKPTMSTPD'
!-----------------------------------------------------------------------
      ! check if the module was already initialised
      if (chpm_ifinit) then
         call mntr_warn(chpm_id,
     $        'module ['//trim(chpm_name)//'] already initiaised.')
         return
      endif

      ! get number of snapshots in a set
      if (PARAM(27).lt.0) then
         chpm_nsnap = NBDINP
      else
         chpm_nsnap = chpm_snmax
      endif

      ! we support only one perturbation
      if (IFPERT) then
         if (NPERT.gt.1) call mntr_abort(chpm_id,
     $         'only single perturbation supported')
      endif

      chpm_ifinit = .true.

      return
      end subroutine
!=======================================================================
!> @brief Check if module was initialised
!! @ingroup chkpoint_mstep
!! @return chkpts_is_initialised
      logical function chkpts_is_initialised()
      implicit none

      include 'SIZE'
      include 'CHKPTMSTPD'
!-----------------------------------------------------------------------
      chkpts_is_initialised = chpm_ifinit

      return
      end function
!=======================================================================
!> @brief Write full file restart set
!! @ingroup chkpoint_mstep
!! @note This interface is defined in @ref chkpt_main.
!! @note This is version of @ref full_restart_save routine.
      subroutine chkpts_write()
      implicit none

      include 'SIZE'            !
      include 'TSTEP'           ! ISTEP, NSTEPS
      include 'INPUT'           ! IFMVBD, IFREGUO
      include 'FRAMELP'
      include 'CHKPOINTD'
      include 'CHKPTMSTPD'

      ! local variables
      integer il, ifile, fnum
      real ltim
      character*132 fname(CHKPTNFMAX)
      logical ifcoord
      logical ifreguol

      character*2 str
      character*200 lstring

      integer icalldl
      save    icalldl
      data    icalldl  /0/

      ! functions
      real dnekclock
!-----------------------------------------------------------------------
      ! no regular mesh
      ifreguol= IFREGUO
      IFREGUO = .false.

      ! do we write a snapshot
      ifile = 0
      if (chpt_stepc.gt.0.and.chpt_stepc.le.chpm_nsnap) then
      ! timing
         ltim = dnekclock()

         ! file number
         ifile = chpm_nsnap - chpt_stepc +1
         if (ifile.eq.1) call mntr_log(chpm_id,lp_inf,
     $                             'Writing checkpoint snapshot')

         ! initialise I/O data
         call io_init

         ! get set of file names in the snapshot
         call chkpt_set_name(fname, fnum, chpt_set_o, ifile)

         ! do we wtrite coordinates; we save coordinates in DNS files only
         if (IFMVBD) then  ! moving boundaries save in every file
            ifcoord = .true.
         elseif (ifile.eq.1) then
            ! perturbation mode with constant base flow - only 1 rsX written
            if (ifpert.and.(.not.ifbase)) then
               if (icalldl.eq.0.and.(.not.chpt_ifrst)) then
                  icalldl = 1
                  ifcoord = .true.
               else
                  call chcopy (fname(1),fname(fnum),132)
                  fnum = 1
                  ifcoord = .false.
               endif
            ! DNS, MHD, perturbation with changing base flow - every first rsX file in snapshot
            else
               ifcoord = .true.
            endif
         else
            if (ifpert.and.(.not.ifbase)) then
               call chcopy (fname(1),fname(fnum),132)
               fnum = 1
            endif
            ifcoord = .false.
         endif

         ! write down files
         call chkpt_restart_write(fname, fnum, ifcoord)

         ! update output set number
         ! we do it after the last file in the set was sucsesfully written
         if (ifile.eq.chpm_nsnap) then
            write(str,'(I2)') chpt_set_o+1
            lstring = 'Written checkpoint snapshot number: '//trim(str)
            call mntr_log(chpm_id,lp_prd,lstring)
         endif

         ! timing
         ltim = dnekclock() - ltim
         call mntr_tmr_add(chpm_twrite_id,1,ltim)
      endif

      ! put parameters back
      IFREGUO = ifreguol

      return
      end subroutine
!=======================================================================
!> @brief Read full file restart set.
!! @ingroup chkpoint_mstep
!! @note This interface is defined in @ref chkpt_main
!! @note This is version of @ref full_restart routine.
      subroutine chkpts_read()
      implicit none

      include 'SIZE'            !
      include 'TSTEP'           ! ISTEP, IF_FULL_PRES
      include 'INPUT'           ! IFREGUO, INITC
      include 'FRAMELP'
      include 'CHKPOINTD'
      include 'CHKPTMSTPD'

      ! local variables
      integer ifile, fnum, fnuml, il
      real dtratio, epsl, ltim
      parameter (epsl = 0.0001)
      logical ifreguol
      character*132 fname(CHKPTNFMAX),fnamel(CHKPTNFMAX)
      character*200 lstring
      integer icalld
      save icalld
      data icalld /0/

      !functions
      real dnekclock
!-----------------------------------------------------------------------
      ! no regular mesh; important for file name generation
      ifreguol= IFREGUO
      IFREGUO = .false.

      ! this is multi step restart so check for timestep consistency is necessary
      ! this routine gets the information of pressure mesh as well
      if (chpt_ifrst.and.icalld.eq.0) then
         call chkpt_dt_get
         icalld = 1
      endif

      if (chpt_ifrst.and.(ISTEP.lt.chpm_nsnap)) then

         ! timing
         ltim = dnekclock()

         ifile = ISTEP+1  ! snapshot number

         ! initialise I/O data
         call io_init

         ! get set of file names in the snapshot
         call chkpt_set_name(fname, fnum, chpt_set_i, ifile)

         ! perturbation mode with constant base flow - only 1 rsX written
         if (ifpert.and.(.not.ifbase)) then
            if (ifile.eq.1) then
               il = 0
               call chkpt_set_name(fnamel, fnuml, il, ifile)
               call chcopy (fname(1),fnamel(1),132)
               fnum = 2
            else
               call chcopy (fname(1),fname(fnum),132)
               fnum = 1
            endif
         endif

         call chkpt_restart_read(fname, fnum)

         ! check time step consistency
         if(ifile.gt.1.and.chpm_dtstep(ifile).gt.0.0) then
            dtratio = abs(DT-chpm_dtstep(ifile))/chpm_dtstep(ifile)
            if (dtratio.gt.epsl) then
                write(lstring,*) 'Time step inconsistent, new=',
     $            DT,', old=',chpm_dtstep(ifile)
               call mntr_warn(chpm_id,lstring)
              ! possible place to exit if this should be trerated as error
            endif
         endif

         ! timing
         ltim = dnekclock() - ltim
         call mntr_tmr_add(chpm_tread_id,1,ltim)
      endif

      ! put parameters back
      IFREGUO = ifreguol
      IF_FULL_PRES=.false.

      return
      end subroutine
!=======================================================================
!> @brief Get old simulation time steps and pressure mesh marker.
!! @ingroup chkpoint_mstep
!! @todo Different files could have different chpm_if_pmesh, so it is
!!    not the best place to read it
      subroutine chkpt_dt_get
      implicit none

      include 'SIZE'
      include 'INPUT'
      include 'RESTART'
      include 'TSTEP'
      include 'FRAMELP'
      include 'CHKPOINTD'
      include 'CHKPTMSTPD'

      ! local variables
      integer ifile, ierr
      real timerl(chpm_snmax), p0thr
      character*132 fname, header
      character*3 prefix
      character*4 dummy
!-----------------------------------------------------------------------
      ! which set of files should be used
      if (ifpert.and.(.not.ifbase)) then
         prefix(1:2)='rp'
      else
         prefix(1:2)='rs'
      endif

      ! initialise I/O data
      call io_init

      ! collect simulation time from file headers
      do ifile=1,chpm_nsnap
         call chkpt_fname(fname, prefix, chpt_set_i, ifile, ierr)
         call mntr_check_abort(chpm_id,ierr,'dt get; file name error')

         ierr = 0
         if (NID.eq.pid00) then
            ! open file
            call addfid(fname,fid0)
            ! add ending character; required by C
            fname = trim(fname)//CHAR(0)
            call byte_open(fname,ierr)
            ! read header
            if (ierr.eq.0) then
               call blank     (header,iHeaderSize)
               call byte_read (header,iHeaderSize/4,ierr)
            endif
            ! close the file
            if (ierr.eq.0) call byte_close(ierr)
         endif
         call mntr_check_abort(chpm_id,ierr,
     $       'dt get; error reading header')

         call bcast(header,iHeaderSize)
         ierr = 0
         if (index(header,'#std').eq.1) then
            read(header,*,iostat=ierr) dummy
     $         ,  wdsizr,nxr,nyr,nzr,nelr,nelgr,timer,istpr
     $         ,  ifiler,nfiler
     $         ,  rdcode      ! 74+20=94
     $         ,  p0thr, chpm_if_pmesh
         else
            ierr = 1
         endif
         call mntr_check_abort(chpm_id,ierr,
     $       'dt get; error extracting timer')

         timerl(ifile) = timer
      enddo

      ! get dt
      do ifile=2,chpm_nsnap
         chpm_dtstep(ifile) = timerl(ifile) - timerl(ifile-1)
      enddo

      return
      end subroutine
!=======================================================================
!> @brief Generate set of restart file names in snapshot
!! @ingroup chkpoint_mstep
!! @param[out] fname  restart file names
!! @param[out] fnum   number of files in snapshot
!! @param[in]  nset   set number
!! @param[in]  ifile  snupshot numer
      subroutine chkpt_set_name(fname, fnum, nset, ifile)
      implicit none

      include 'SIZE'            ! NIO
      include 'INPUT'           ! IFMHD, IFPERT, IFBASE
      include 'FRAMELP'
      include 'CHKPTMSTPD'

      ! argument list
      character*132 fname(CHKPTNFMAX)
      integer fnum, nset, ifile

      ! local variables
      integer ifilel, ierr

      character*132 bname
      character*3 prefix
!-----------------------------------------------------------------------
      ! fill fname array with 'rsX' (DNS), 'rpX' (pert.) and 'rbX' (MHD) file names
      if (IFMHD) then
         ! file number
         fnum = 2

         ! prefix and name for fluid (DNS)
         prefix(1:2)='rs'
         call chkpt_fname(fname(1), prefix, nset, ifile, ierr)
         call mntr_check_abort(chpm_id,ierr,
     $        'chkpt_set_name; DNS file name error')

         ! prefix and name for magnetic field (MHD)
         prefix(1:2)='rb'
         call chkpt_fname(fname(2), prefix, nset, ifile, ierr)
         call mntr_check_abort(chpm_id,ierr,
     $        'chkpt_set_name; MHD file name error')

      elseif (IFPERT) then
         ! file number
         ! I assume only single perturbation
         fnum = 2

         ! prefix and name for base flow (DNS)
         prefix(1:2)='rs'
         if (IFBASE) then
            ifilel = ifile
         else
            ifilel =1
         endif
         call chkpt_fname(fname(1), prefix, nset, ifilel, ierr)
         call mntr_check_abort(chpm_id,ierr,
     $        'chkpt_set_name; base flow file name error')

         ! prefix and name for perturbation
         prefix(1:2)='rp'
         call chkpt_fname(fname(2), prefix, nset, ifile, ierr)
         call mntr_check_abort(chpm_id,ierr,
     $        'chkpt_set_name; perturbation file name error')

      else                ! DNS
         fnum = 1

         ! create prefix and name for DNS
         prefix(1:2)='rs'
         call chkpt_fname(fname(1), prefix, nset, ifile, ierr)
         call mntr_check_abort(chpm_id,ierr,
     $        'chkpt_set_name; DNS file name error')

      endif

      return
      end subroutine
!=======================================================================
!> @brief Generate single restart file name
!! @ingroup chkpoint_mstep
!! @param[out] fname  restart file name
!! @param[in]  prefix prefix
!! @param[in]  nset   set number
!! @param[in]  ifile  snupshot numer
!! @param[out] ierr   error mark
      subroutine chkpt_fname(fname, prefix, nset, ifile, ierr)
      implicit none

      include 'SIZE'            ! NIO
      include 'INPUT'           ! SESSION
      include 'CHKPOINTD'
      include 'CHKPTMSTPD'

      ! argument list
      character*132 fname
      character*3 prefix
      integer nset, ifile, ierr

      ! local variables
      character*132 bname    ! base name
      character*132 fnamel   ! local file name
      character*3 prefixl    ! local prefix
      integer itmp

      character*6  str

      character*(*) kst
      parameter(kst='0123456789abcdefx')
!-----------------------------------------------------------------------
      ! create prefix and name for DNS
      ierr = 0
      prefixl(1:2) = prefix(1:2)
      itmp=min(17,chpt_nset*chpm_nsnap) + 1
      prefixl(3:3)=kst(itmp:itmp)

      ! get base name (SESSION)
      bname = trim(adjustl(SESSION))

      call io_mfo_fname(fnamel,bname,prefixl,ierr)
      if (ierr.ne.0) then
         call mntr_error(chpm_id,'chkpt_fname; file name error')
         return
      endif

      write(str,'(i5.5)') chpm_nsnap*nset+ifile
      fname = trim(fnamel)//trim(str)

      return
      end subroutine
!=======================================================================
!> @brief Write checkpoint snapshot.
!! @ingroup chkpoint_mstep
!! @param[out] fname   restart file name
!! @param[in]  fnum    number of files in snapshot
!! @param[in]  ifcoord do we save coordinates
      subroutine chkpt_restart_write(fname, fnum, ifcoord)
      implicit none

      include 'SIZE'
      include 'RESTART'
      include 'TSTEP'
      include 'INPUT'
      include 'CHKPTMSTPD'

      ! argument list
      character*132 fname(CHKPTNFMAX)
      integer fnum
      logical ifcoord

      ! local variables
      integer lwdsizo
      integer ipert, il
      ! which set of variables do we write: DNS (1), MHD (2) or perturbation (3)
      integer chktype

      logical lif_full_pres, lifxyo, lifpo, lifvo, lifto,
     $        lifpsco(LDIMT1)
!-----------------------------------------------------------------------
      ! adjust I/O parameters
      lwdsizo = WDSIZO
      WDSIZO  = 8
      lif_full_pres = IF_FULL_PRES
      IF_FULL_PRES = .true.
      lifxyo = IFXYO
      lifpo= IFPO
      IFPO = .TRUE.
      lifvo= IFVO
      IFVO = .TRUE.
      lifto= IFTO
      IFTO = IFHEAT
      do il=1,NPSCAL
         lifpsco(il)= IFPSCO(il)
         IFPSCO(il) = .TRUE.
      enddo

      if (IFMHD) then
         ! DNS first
         IFXYO = ifcoord
         chktype = 1
         call chkpt_mfo(fname(1),chktype,ipert)

         ! MHD
         IFXYO = .FALSE.
         chktype = 2
         call chkpt_mfo(fname(2),chktype,ipert)

      elseif (IFPERT) then
         ! DNS first
         if (fnum.eq.2) then
            IFXYO = ifcoord
            chktype = 1
            call chkpt_mfo(fname(1),chktype,ipert)
         endif

         ! perturbation
         IFXYO = .FALSE.
         chktype = 3
         ipert = 1
         call chkpt_mfo(fname(fnum),chktype,ipert)
      else ! DNS
         ! write only one set of files
         if (fnum.ne.1) call mntr_abort(chpm_id,
     $        'chkpt_restart_save; too meny files for DNS')

         IFXYO = ifcoord
         chktype = 1
         call chkpt_mfo(fname(1),chktype,ipert)
      endif

      ! restore I/O parameters
      WDSIZO = lwdsizo
      IF_FULL_PRES = lif_full_pres
      IFXYO = lifxyo
      IFPO = lifpo
      IFVO = lifvo
      IFTO = lifto
      do il=1,NPSCAL
         IFPSCO(il) = lifpsco(il)
      enddo

      return
      end subroutine
!=======================================================================
!> @brief Read checkpoint snapshot.
!! @ingroup chkpoint_mstep
!! @param[out] fname   restart file name
!! @param[in]  fnum    number of files in snapshot
      subroutine chkpt_restart_read(fname, fnum)
      implicit none

      include 'SIZE'
      include 'RESTART'
      include 'TSTEP'
      include 'INPUT'
      include 'CHKPTMSTPD'

      ! argument list
      character*132 fname(CHKPTNFMAX)
      integer fnum

      ! local variables
      integer ndumps, ipert, il
      ! which set of variables do we write: DNS (1), MHD (2) or perturbation (3)
      integer chktype
      character*132 fnamel
!-----------------------------------------------------------------------
      if (IFMHD) then
         ! DNS first
         chktype = 1
         call sioflag(ndumps,fnamel,fname(1))
         call chkpt_mfi(fnamel,chktype,ipert)

         ! MHD
         chktype = 2
         call sioflag(ndumps,fnamel,fname(2))
         call chkpt_mfi(fnamel,chktype,ipert)

      elseif (IFPERT) then
         ! DNS first
         if (fnum.eq.2) then
            chktype = 1
            call sioflag(ndumps,fnamel,fname(1))
            call chkpt_mfi(fnamel,chktype,ipert)
         endif

         ! perturbation
         chktype = 3
         ipert = 1
         call sioflag(ndumps,fnamel,fname(fnum))
         call chkpt_mfi(fnamel,chktype,ipert)
      else ! DNS
         ! read only one set of files
         if (fnum.ne.1) call mntr_abort(chpm_id,
     $        'chkpt_restart_read; too meny files for DNS')

         chktype = 1
         call sioflag(ndumps,fnamel,fname(1))
         call chkpt_mfi(fnamel,chktype,ipert)
      endif

      return
      end subroutine
!=======================================================================
!> @brief Write field to the file
!! @details This routine is based on @ref mfo_outfld but does not assume
!!    any file numbering. It is optimised for chekpoint writing.
!! @ingroup chkpoint_mstep
!! @param[in]   fname      file name
!! @param[in]   chktype    data type to write (DNS, MHD, perturbation)
!! @param[in]   ipert      index of perturbation field
!! @note Only one set of data (DNS, MHD or perturbation) can be saved in
!!    single file
!! @remark This routine uses global scratch space \a SCRCG.
      subroutine chkpt_mfo(fname,chktype,ipert)
      implicit none

      include 'SIZE'
      include 'INPUT'
      include 'PARALLEL'
      include 'RESTART'
      include 'TSTEP'
      include 'GEOM'
      include 'SOLN'
      include 'FRAMELP'
      include 'CHKPTMSTPD'

      ! argumnt list
      character*132 fname
      integer chktype, ipert

      ! local variables
      integer ierr, il, itmp
      integer ioflds
      integer*8 offs,nbyte
      real dnbyte, tiostart, tio

      ! functions
      real dnekclock_sync, glsum

      real pm1(lx1,ly1,lz1,lelv)
      common /SCRCG/ pm1
!-----------------------------------------------------------------------
      ! simple timing
      tiostart=dnekclock_sync()

      ! set elelemnt size
      NXO  = NX1
      NYO  = NY1
      NZO  = NZ1

      ! open file
      call io_mbyte_open(fname,ierr)
      call mntr_check_abort(chpm_id,ierr,'chkpt_mfo; file not opened.')

      ! write a header and create element mapping
      call mfo_write_hdr

      ! set header offset
      offs = iHeaderSize + 4 + isize*nelgt
      ioflds = 0

      ! write fields
      ! coordinates
      if (ifxyo) then
         call io_mfov(offs,xm1,ym1,zm1,nx1,ny1,nz1,nelt,nelgt,ndim)
         ioflds = ioflds + ndim
      endif

      ! velocity, magnetic field, perturbation velocity
      if (ifvo) then
         if (chktype.eq.1) then
            call io_mfov(offs,vx,vy,vz,nx1,ny1,nz1,nelt,nelgt,ndim)
         elseif(chktype.eq.2) then
            call io_mfov(offs,bx,by,bz,nx1,ny1,nz1,nelt,nelgt,ndim)
         elseif(chktype.eq.3) then
            call io_mfov(offs,vxp(1,ipert),vyp(1,ipert),
     $                       vzp(1,ipert),nx1,ny1,nz1,nelt,nelgt,ndim)
         endif
         ioflds = ioflds + ndim
      endif

      ! pressure
      if (ifpo) then
         if (chktype.eq.1) then
            ! copy array if necessary
            if (ifsplit) then
               itmp = nx1*ny1*nz1*lelv
               call io_mfos(offs,pr,nx2,ny2,nz2,nelt,nelgt,ndim)
            else
               itmp = nx1*ny1*nz1*lelv
               call rzero(pm1,itmp)
               itmp = nx2*ny2*nz2
               do il=1,nelv
                  call copy(pm1(1,1,1,il),pr(1,1,1,il),itmp)
               enddo
               call io_mfos(offs,pm1,nx1,ny1,nz1,nelt,nelgt,ndim)
            endif
         elseif(chktype.eq.2) then
            ! copy array
            itmp = nx1*ny1*nz1*lelv
            call rzero(pm1,itmp)
            itmp = nx2*ny2*nz2
            do il=1,nelv
               call copy(pm1(1,1,1,il),pm(1,1,1,il),itmp)
            enddo
            call io_mfos(offs,pm1,nx1,ny1,nz1,nelt,nelgt,ndim)
         elseif(chktype.eq.3) then
            ! copy array
            itmp = nx1*ny1*nz1*lelv
            call rzero(pm1,itmp)
            itmp = nx2*ny2*nz2
            do il=1,nelv
               call copy(pm1(1,1,1,il),prp(1+itmp*(il-1),ipert),itmp)
            enddo
            call io_mfos(offs,pm1,nx1,ny1,nz1,nelt,nelgt,ndim)
         endif
         ioflds = ioflds + 1
      endif

      if (chktype.ne.2) then
         if (ifto) then
            if (chktype.eq.1) then
               call io_mfos(offs,t,nx1,ny1,nz1,nelt,nelgt,ndim)
            elseif(chktype.eq.3) then
               call io_mfos(offs,tp(1,1,ipert),
     $                          nx1,ny1,nz1,nelt,nelgt,ndim)
            endif
            ioflds = ioflds + 1
         endif

         do il=1,ldimt-1
            if (ifpsco(il)) then
               if (chktype.eq.1) then
                  call io_mfos(offs,t(1,1,1,1,il+1),
     $                 nx1,ny1,nz1,nelt,nelgt,ndim)
               elseif(chktype.eq.3) then
                  call io_mfos(offs,tp(1,il+1,ipert),
     $                 nx1,ny1,nz1,nelt,nelgt,ndim)
               endif
               ioflds = ioflds + 1
            endif
         enddo
      endif
      dnbyte = 1.*ioflds*nelt*wdsizo*nx1*ny1*nz1

      ! possible place for metadata

      ! close file
      call io_mbyte_close(ierr)
      call mntr_check_abort(chpm_id,ierr,'chkpt_mfo; file not closed.')

      ! stamp the log
      tio = dnekclock_sync()-tiostart
      if (tio.le.0) tio=1.

      dnbyte = glsum(dnbyte,1)
      dnbyte = dnbyte + iHeaderSize + 4. + isize*nelgt
      dnbyte = dnbyte/1024/1024

      call mntr_log(chpm_id,lp_prd,'Checkpoint written:')
      call mntr_logr(chpm_id,lp_vrb,'file size (MB) = ',dnbyte)
      call mntr_logr(chpm_id,lp_vrb,'avg data-throughput (MB/s) = ',
     $     dnbyte/tio)
      call mntr_logi(chpm_id,lp_vrb,'io-nodes = ',nfileo)

      return
      end subroutine
!=======================================================================
!> @brief Read field to the file
!! @details This routine is based on @ref mfi but supports perturbation
!!    as well. It is optimised for chekpoint reading.
!! @ingroup chkpoint_mstep
!! @param[in]   fname      file name
!! @param[in]   chktype    data type to read (DNS, MHD, preturbation)
!! @param[in]   ipert      index of perturbation field
!! @remark This routine uses global scratch space \a SCRUZ.
      subroutine chkpt_mfi(fname,chktype,ipert)
      implicit none

      include 'SIZE'
      include 'INPUT'
      include 'PARALLEL'
      include 'RESTART'
      include 'TSTEP'
      include 'GEOM'
      include 'SOLN'
      include 'FRAMELP'
      include 'CHKPTMSTPD'

      ! argumnt list
      character*132 fname
      integer chktype, ipert

      ! local variables
      integer ierr, il, jl, kl
      integer itmp1, itmp2, itmp3
      integer ioflds
      integer*8 offs0,offs,nbyte
      real dnbyte, tiostart, tio
      logical ifskip

      !     scratch arrays
      integer lwkv
      parameter (lwkv = lx1*ly1*lz1*lelt)
      real wkv1(lwkv),wkv2(lwkv),wkv3(lwkv)
      common /scruz/ wkv1,wkv2,wkv3

      ! functions
      real dnekclock_sync, glsum
!-----------------------------------------------------------------------
      ! simple timing
      tiostart=dnekclock_sync()

      ! open file and read header; some operations related to header are
      ! performed in chkpts_read; it is not the optimal way, but I don't want
      ! to modify mfi_prepare
      call mfi_prepare(fname)

      ! set header offset
      offs = iHeaderSize + 4 + isize*nelgr
      ioflds = 0

      ! read fields
      ! coordinates
      if (ifgetxr) then
         ifskip = .not.ifgetx
         ! skip coordinates if you need to interpolate them;
         ! I assume current coordinates are more exact than the interpolated one
         if ((nxr.eq.lx1).and.(nyr.eq.ly1).and.(nzr.eq.lz1)) then
            call io_mfiv(offs,xm1,ym1,zm1,lx1,ly1,lz1,lelt,ifskip)
         else
            ifskip=.TRUE.
            call io_mfiv(offs,wkv1,wkv2,wkv3,nxr,nyr,nzr,lelt,ifskip)
         endif
         ioflds = ioflds + ldim
      endif

      ! velocity, magnetic field, perturbation velocity
      if (ifgetur) then
         ifskip = .not.ifgetu
         if ((nxr.eq.lx1).and.(nyr.eq.ly1).and.(nzr.eq.lz1)) then
            ! unchanged resolution
            ! read field directly to the variables
            if (chktype.eq.1) then
               call io_mfiv(offs,vx,vy,vz,lx1,ly1,lz1,lelv,ifskip)
            elseif(chktype.eq.2) then
               call io_mfiv(offs,bx,by,bz,lx1,ly1,lz1,lelv,ifskip)
            elseif(chktype.eq.3) then
               call io_mfiv(offs,vxp(1,ipert),vyp(1,ipert),vzp(1,ipert)
     $                   ,lx1,ly1,lz1,lelv,ifskip)
            endif
         else
            ! modified resolution
            ! read field to tmp array
            call io_mfiv(offs,wkv1,wkv2,wkv3,nxr,nyr,nzr,lelt,ifskip)

            ! interpolate
            if (ifgetu) then
               if (chktype.eq.1) then
                  call chkpt_map_gll(vx,wkv1,nxr,nzr,nelv)
                  call chkpt_map_gll(vy,wkv2,nxr,nzr,nelv)
                  if (if3d) call chkpt_map_gll(vz,wkv3,nxr,nzr,nelv)
               elseif(chktype.eq.2) then
                  call chkpt_map_gll(bx,wkv1,nxr,nzr,nelv)
                  call chkpt_map_gll(by,wkv2,nxr,nzr,nelv)
                  if (if3d) call chkpt_map_gll(bz,wkv3,nxr,nzr,nelv)
               elseif(chktype.eq.3) then
                  call chkpt_map_gll(vxp(1,ipert),wkv1,nxr,nzr,nelv)
                  call chkpt_map_gll(vyp(1,ipert),wkv2,nxr,nzr,nelv)
                  if (if3d) call chkpt_map_gll(vzp(1,ipert),wkv3,
     $                        nxr,nzr,nelv)
               endif
            endif
         endif
         ioflds = ioflds + ndim
      endif

      ! pressure
      if (ifgetpr) then
         ifskip = .not.ifgetp

         if (chpm_if_pmesh) then
            ! file contains pressure on nxr-2 (GL) mesh
            ! read field to tmp array
            call io_mfis(offs,wkv1,nxr,nyr,nzr,lelt,ifskip)

            if (ifgetp) then
               if ((nxr.eq.lx1).and.(nyr.eq.ly1).and.(nzr.eq.lz1)) then
                  ! unchanged resolution
                  if (ifsplit) then
                     if (chktype.eq.1) then
                        !interpolate GL to GLL
                        itmp1 = nx1*ny1*nz1
                        jl = 1
                        do il=1,nelv
                           call map21t (pr(1,1,1,il),wkv1(jl),il)
                           jl = jl +itmp1
                        enddo
                     endif
                  else
                     ! remove zeros
                     itmp1 = nx1*ny1*nz1
                     itmp2 = nx2*ny2*nz2
                     jl = 1
                     if(chktype.eq.1) then
                        do il=1,nelv
                           call copy(pr(1,1,1,il),wkv1(jl),itmp2)
                           jl = jl + itmp1
                        enddo
                     elseif(chktype.eq.2) then
                        do il=1,nelv
                           call copy(pm(1,1,1,il),wkv1(jl),itmp2)
                           jl = jl + itmp1
                        enddo
                     elseif(chktype.eq.3) then
                        kl = 1
                        do il=1,nelv
                           call copy(prp(kl,ipert),wkv1(jl),itmp2)
                           jl = jl + itmp1
                           kl = kl + itmp2
                        enddo
                     endif
                  endif
               else
                  ! modified resolution
                  ! remove zeros
                  itmp1 = nxr*nyr*nzr
                  itmp3 = max(nzr-2,1)
                  itmp2 = (nxr-2)*(nyr-2)*itmp3
                  jl = 1
                  kl = 1
                  do il=1,nelv
                     call copy(wkv2(kl),wkv1(jl),itmp2)
                     jl = jl + itmp1
                     kl = kl + itmp2
                  enddo

                  if (ifsplit) then
                     if (chktype.eq.1) then
                        ! interpolate on GL mesh
                        call chkpt_map_gl(wkv1,wkv2,nxr-2,itmp3,nelv)

                        !interpolate GL to GLL
                        itmp2 = nx2*ny2*nz2
                        jl = 1
                        do il=1,nelv
                           call map21t (pr(1,1,1,il),wkv1(jl),il)
                           jl = jl +itmp2
                        enddo
                     endif
                  else
                     ! interpolate on GL mesh
                     if (chktype.eq.1) then
                        call chkpt_map_gl(pr,wkv2,nxr-2,itmp3,nelv)
                     elseif(chktype.eq.2) then
                        call chkpt_map_gl(pm,wkv2,nxr-2,itmp3,nelv)
                     elseif(chktype.eq.3) then
                        call chkpt_map_gl(prp(1,ipert),wkv2,nxr-2,
     $                       itmp3,nelv)
                     endif
                  endif
               endif
            endif

         else
            ! file contains pressure on nxr (GLL) mesh
            if ((nxr.eq.lx1).and.(nyr.eq.ly1).and.(nzr.eq.lz1)) then
               ! unchanged resolution
               if (ifsplit) then
                  ! read field directly to the variables
                  if (chktype.eq.1) then
                     call io_mfis(offs,pr,lx1,ly1,lz1,lelv,ifskip)
                  endif
               else
                  ! read field to tmp array
                  call io_mfis(offs,wkv1,nxr,nyr,nzr,lelt,ifskip)

                  ! interpolate GLL to GL
                  if (ifgetp) then
                     itmp2 = nx1*ny1*nz1
                     itmp2 = nx2*ny2*nz2
                     jl = 1
                     if (chktype.eq.1) then
                        do il=1,nelv
                           call map12 (pr(1,1,1,il),wkv1(jl),il)
                           jl = jl +itmp1
                        enddo
                     elseif(chktype.eq.2) then
                        do il=1,nelv
                           call map12 (pm(1,1,1,il),wkv1(jl),il)
                           jl = jl +itmp1
                        enddo
                     elseif(chktype.eq.3) then
                        kl = 1
                        do il=1,nelv
                           call map12 (prp(kl,ipert),wkv1(jl),il)
                           jl = jl +itmp1
                           kl = kl +itmp2
                        enddo
                     endif
                  endif
               endif

            else
               ! modified resolution
               ! read field to tmp array
               call io_mfis(offs,wkv1,nxr,nyr,nzr,lelt,ifskip)

               if (ifgetp) then
                  if (ifsplit) then
                     ! interpolate on GLL
                     call chkpt_map_gll(pr,wkv1,nxr,nzr,nelv)
                  else
                     ! interpolate on GLL
                     call chkpt_map_gll(wkv2,wkv1,nxr,nzr,nelv)

                     ! interpolate GLL to GL
                     itmp2 = nx1*ny1*nz1
                     itmp2 = nx2*ny2*nz2
                     jl = 1
                     if (chktype.eq.1) then
                        do il=1,nelv
                           call map12 (pr(1,1,1,il),wkv2(jl),il)
                           jl = jl +itmp1
                        enddo
                     elseif(chktype.eq.2) then
                        do il=1,nelv
                           call map12 (pm(1,1,1,il),wkv2(jl),il)
                           jl = jl +itmp1
                        enddo
                     elseif(chktype.eq.3) then
                        kl = 1
                        do il=1,nelv
                           call map12 (prp(kl,ipert),wkv2(jl),il)
                           jl = jl +itmp1
                           kl = kl +itmp2
                        enddo
                     endif
                  endif
               endif
            endif
         endif

         ioflds = ioflds + 1
      endif

      if (chktype.ne.2) then
         if (ifgettr) then
            ifskip = .not.ifgett
            if ((nxr.eq.lx1).and.(nyr.eq.ly1).and.(nzr.eq.lz1)) then
               ! unchanged resolution
               ! read field directly to the variables
               if (chktype.eq.1) then
                  call io_mfis(offs,t,lx1,ly1,lz1,lelt,ifskip)
               elseif(chktype.eq.3) then
                  call io_mfis(offs,tp(1,1,ipert),lx1,ly1,lz1,lelt,
     $                 ifskip)
               endif
            else
               ! modified resolution
               ! read field to tmp array
               call io_mfis(offs,wkv1,nxr,nyr,nzr,lelt,ifskip)

               ! interpolate
               if (ifgett) then
                  if (chktype.eq.1) then
                     call chkpt_map_gll(t,wkv1,nxr,nzr,nelt)
                  elseif(chktype.eq.3) then
                     call chkpt_map_gll(tp(1,1,ipert),wkv1,nxr,nzr,nelt)
                  endif
               endif
            endif
            ioflds = ioflds + 1
         endif

         do il=1,ldimt-1
            if (ifgtpsr(il)) then
               ifskip = .not.ifgtps(il)
               if ((nxr.eq.lx1).and.(nyr.eq.ly1).and.(nzr.eq.lz1)) then
                  ! unchanged resolution
                  ! read field directly to the variables
                  if (chktype.eq.1) then
                     call io_mfis(offs,t(1,1,1,1,il+1),lx1,ly1,lz1,
     $                            lelt,ifskip)
                  elseif(chktype.eq.3) then
                     call io_mfis(offs,tp(1,il+1,ipert),lx1,ly1,lz1,
     $                            lelt,ifskip)
                  endif
               else
                  ! modified resolution
                  ! read field to tmp array
                  call io_mfis(offs,wkv1,nxr,nyr,nzr,lelt,ifskip)

                  ! interpolate
                  if (ifgtps(il)) then
                     if (chktype.eq.1) then
                        call chkpt_map_gll(t(1,1,1,1,il+1),wkv1,
     $                                    nxr,nzr,nelt)
                     elseif(chktype.eq.3) then
                        call chkpt_map_gll(tp(1,il+1,ipert),wkv1,
     $                                    nxr,nzr,nelt)
                     endif
                  endif
               endif
               ioflds = ioflds + 1
            endif
         enddo
      endif

      if (ifgtim) time = timer

      ! close file
      call io_mbyte_close(ierr)
      call mntr_check_abort(chpm_id,ierr,'chkpt_mfi; file not closed.')

      ! stamp the log
      tio = dnekclock_sync()-tiostart
      if (tio.le.0) tio=1.

      if(nid.eq.pid0r) then
         dnbyte = 1.*ioflds*nelr*wdsizr*nxr*nyr*nzr
      else
         dnbyte = 0.0
      endif

      dnbyte = glsum(dnbyte,1)
      dnbyte = dnbyte + iHeaderSize + 4. + isize*nelgt
      dnbyte = dnbyte/1024/1024

      call mntr_log(chpm_id,lp_prd,'Checkpoint read:')
      call mntr_logr(chpm_id,lp_vrb,'avg data-throughput (MB/s) = ',
     $     dnbyte/tio)
      call mntr_logi(chpm_id,lp_vrb,'io-nodes = ',nfileo)

      if (ifaxis) call chkpt_axis_interp_ic()

      return
      end subroutine
!=======================================================================
!> @brief Interpolate input on velocity mesh
!! @details This is version of @ref mapab with corrected array sizes.
!!    It iterpolates fields defined on GLL points. Like
!!    the orginal routine I assume NXR=NYR=NZR, or NXR=NYR, NZR=1
!! @ingroup chkpoint_mstep
!! @param[out]   xf           output field on velocity mesh
!! @param[in]    yf           input field on velocity mesh
!! @param[in]    nxr, nzr     array sizes
!! @param[in]    nel          element number
!! @remarks This routine uses global scratch space CTMP0, CTMPABM1
      subroutine chkpt_map_gll(xf,yf,nxr,nzr,nel)
      implicit none

      include 'SIZE'
      include 'INPUT'
      include 'IXYZ'
      include 'WZ'

      ! argument lists
      integer nxr, nzr, nel
      real xf(lx1,ly1,lz1,nel), yf(nxr,nxr,nzr,nel)

      ! local variables
      integer nyzr, nxy2
      integer ie, iz, izoff

      ! moddificaion flag
      integer nold
      save    nold
      data    nold /0/

      ! work arrays
      integer lxr, lyr, lzr, lxyzr
      parameter (lxr=lx1+6)
      parameter (lyr=ly1+6)
      parameter (lzr=lz1+6)
      parameter (lxyzr=lxr*lyr*lzr)
      real txa(lxyzr),txb(lx1,ly1,lzr),zgmr(lxr),wgtr(lxr)
      common /ctmp0/  txa, txb, zgmr, wgtr

      ! interpolation arrays
      real ires(lxr*lxr)  ,itres(lxr*lxr)
      common /ctmpabm1/ ires, itres
!-----------------------------------------------------------------------
      nyzr = nxr*nzr
      nxy2 = lx1*ly1

      if (nxr.ne.nold) then
         nold=nxr
         call zwgll(zgmr,wgtr,nxr)
         call igllm(ires,itres,zgmr,zgm1,nxr,lx1,nxr,lx1)
      endif

      do ie=1,nel
         call mxm (ires,lx1,yf(1,1,1,ie),nxr,txa,nyzr)
         do iz=1,nzr
            izoff = 1 + (iz-1)*lx1*nxr
            call mxm (txa(izoff),lx1,itres,nxr,txb(1,1,iz),ly1)
         enddo
         if (if3d) then
            call mxm (txb,nxy2,itres,nzr,xf(1,1,1,ie),lz1)
         else
            call copy(xf(1,1,1,ie),txb,nxy2)
         endif
      enddo

      return
      end subroutine
!=======================================================================
!> @brief Interpolate pressure input
!! @details This is version of @ref mapab modified to work with pressure
!!    mesh. It iterpolates fields defined on GL points. Like
!!    the orginal routine I assume NXR=NYR=NZR, or NXR=NYR, NZR=1
!! @ingroup chkpoint_mstep
!! @param[out]   xf           output field on pressure mesh
!! @param[in]    yf           input field on pressure mesh
!! @param[in]    nxr, nzr     array sizes
!! @param[in]    nel          element number
!! @remarks This routine uses global scratch space CTMP0, CTMPABM2
      subroutine chkpt_map_gl(xf,yf,nxr,nzr,nel)
      implicit none

      include 'SIZE'
      include 'INPUT'
      include 'IXYZ'
      include 'WZ'

      ! argument lists
      integer nxr, nzr, nel
      real xf(lx2,ly2,lz2,nel), yf(nxr,nxr,nzr,nel)

      ! local variables
      integer nyzr, nxy2
      integer ie, iz, izoff

      ! moddificaion flag
      integer nold
      save    nold
      data    nold /0/

      ! work arrays
      integer lxr, lyr, lzr, lxyzr
      parameter (lxr=lx2+6)
      parameter (lyr=ly2+6)
      parameter (lzr=lz2+6)
      parameter (lxyzr=lxr*lyr*lzr)
      real txa(lxyzr),txb(lx2,ly2,lzr),zgmr(lxr),wgtr(lxr)
      common /ctmp0/  txa, txb, zgmr, wgtr

      ! interpolation arrays
      real ires(lxr,lxr)  ,itres(lxr,lxr)
      common /ctmpabm2/ ires, itres
!-----------------------------------------------------------------------
      nyzr = nxr*nzr
      nxy2 = lx2*ly2

      if (nxr.ne.nold) then
         nold=nxr
         call zwgl   (zgmr,wgtr,nxr)
         call iglm   (ires,itres,zgmr,zgm2,nxr,lx2,nxr,lx2)
      endif

      do ie=1,nel
         call mxm (ires,lx2,yf(1,1,1,ie),nxr,txa,nyzr)
         do iz=1,nzr
            izoff = 1 + (iz-1)*lx2*nxr
            call mxm (txa(izoff),lx2,itres,nxr,txb(1,1,iz),ly2)
         enddo
         if (if3d) then
            call mxm (txb,nxy2,itres,nzr,xf(1,1,1,ie),lz2)
         else
            call copy(xf(1,1,1,ie),txb,nxy2)
         endif
      enddo

      return
      end subroutine
!=======================================================================
!> @brief Map loaded variables from velocity to axisymmetric mesh
!! @ingroup chkpoint_mstep
!! @note This is version of @ref axis_interp_ic taking into account fact
!! pressure does not have to be written on velocity mesh.
!! @remark This routine uses global scratch space \a CTMP0.
      subroutine chkpt_axis_interp_ic()
      implicit none

      include 'SIZE'
      include 'INPUT'
      include 'TSTEP'
      include 'RESTART'
      include 'SOLN'
      include 'GEOM'
      include 'IXYZ'

      ! scratch space
      real axism1 (lx1,ly1), axism2 (lx2,ly2), ialj2 (ly2,ly2),
     $     iatlj2(ly2,ly2), tmp(ly2,ly2)
      common /ctmp0/ axism1, axism2, ialj2, iatlj2, tmp

      ! local variables
      integer el, ips, is1
!-----------------------------------------------------------------------
      if (.not.ifaxis) return

      ! get interpolation operators between Gauss-Lobatto Jacobi
      ! and and Gauss Legendre poits (this is missing in genwz)
      !call invmt(iajl2 ,ialj2 ,tmp ,ly2)
      call invmt(iatjl2,iatlj2,tmp,ly2)

      do el=1,nelv
         if (ifrzer(el)) then
           if (ifgetx) then
             call mxm(xm1(1,1,1,el),nx1,iatlj1,ny1,axism1,ny1)
             call copy(xm1(1,1,1,el),axism1,nx1*ny1)
             call mxm(ym1(1,1,1,el),nx1,iatlj1,ny1,axism1,ny1)
             call copy(ym1(1,1,1,el),axism1,nx1*ny1)
           endif
           if (ifgetu) then
             call mxm(vx(1,1,1,el),nx1,iatlj1,ny1,axism1,ny1)
             call copy(vx(1,1,1,el),axism1,nx1*ny1)
             call mxm(vy(1,1,1,el),nx1,iatlj1,ny1,axism1,ny1)
             call copy(vy(1,1,1,el),axism1,nx1*ny1)
           endif
           if (ifgetw) then
             call mxm(vz(1,1,1,el),nx1,iatlj1,ny1,axism1,ny1)
             call copy(vz(1,1,1,el),axism1,nx1*ny1)
           endif
           if (ifgetp) then
             if (ifsplit) then
                call mxm(pr(1,1,1,el),nx1,iatlj1,ny1,axism1,ny1)
                call copy(pr(1,1,1,el),axism1,nx1*ny1)
             else
                call mxm(pr(1,1,1,el),nx2,iatlj2,ny2,axism2,ny2)
                call copy(pr(1,1,1,el),axism2,nx2*ny2)
             endif
           endif
           if (ifgett) then
             call mxm(t(1,1,1,el,1),nx1,iatlj1,ny1,axism1,ny1)
             call copy(t(1,1,1,el,1),axism1,nx1*ny1)
           endif
           do ips=1,npscal
            is1 = ips + 1
            if (ifgtps(ips)) then
             call mxm(t(1,1,1,el,is1),nx1,iatlj1,ny1,axism1,ny1)
             call copy(t(1,1,1,el,is1),axism1,nx1*ny1)
            endif
           enddo
         endif
      enddo

      return
      end subroutine
!=======================================================================


!> @file chkpoint.f
!! @ingroup chkpoint
!! @brief Set of checkpoint routines
!! @details This is a main interface reading/writing runtime parameters
!! and calling proper submodule.
!=======================================================================
!> @brief Register checkpointing module
!! @ingroup chkpoint
!! @note This routine should be called in frame_usr_register
      subroutine chkpt_register()
      implicit none

      include 'SIZE'
      include 'FRAMELP'
      include 'CHKPOINTD'

      ! local variables
      integer lpmid
      real ltim

      ! functions
      real dnekclock
!-----------------------------------------------------------------------
      ! timing
      ltim = dnekclock()

      ! check if the current module was already registered
      call mntr_mod_is_name_reg(lpmid,chpt_name)
      if (lpmid.gt.0) then
         call mntr_warn(lpmid,
     $        'module ['//trim(chpt_name)//'] already registered')
         return
      endif

      ! find parent module
      call mntr_mod_is_name_reg(lpmid,'FRAME')
      if (lpmid.le.0) then
         lpmid = 1
         call mntr_abort(lpmid,
     $        'Parent module ['//'FRAME'//'] not registered')
      endif

      ! register module
      call mntr_mod_reg(chpt_id,lpmid,chpt_name,'Checkpointing I/O')

      ! register timer
      call mntr_tmr_is_name_reg(lpmid,'FRM_TOT')
      call mntr_tmr_reg(chpt_ttot_id,lpmid,chpt_id,
     $      'CHP_TOT','Checkpointing total time',.false.)

      call mntr_tmr_reg(chpt_tini_id,chpt_ttot_id,chpt_id,
     $      'CHP_INI','Checkpointing initialisation time',.true.)

      ! register and set active section
      call rprm_sec_reg(chpt_sec_id,chpt_id,'_'//adjustl(chpt_name),
     $     'Runtime paramere section for checkpoint module')
      call rprm_sec_set_act(.true.,chpt_sec_id)

      ! register parameters
      call rprm_rp_reg(chpt_ifrst_id,chpt_sec_id,'READCHKPT',
     $     'Restat from checkpoint',rpar_log,0,0.0,.false.,' ')

      call rprm_rp_reg(chpt_fnum_id,chpt_sec_id,'CHKPFNUMBER',
     $     'Restart file number',rpar_int,1,0.0,.false.,' ')

      call rprm_rp_reg(chpt_step_id,chpt_sec_id,'CHKPINTERVAL',
     $     'Checkpiont saving frequency (number of time steps)',
     $      rpar_int,500,0.0,.false.,' ')

      ! set initial step delay
      call mntr_set_step_delay(1)

      ! call submodule registration
      call chkpts_register

      ! timing
      ltim = dnekclock() - ltim
      call mntr_tmr_add(chpt_tini_id,1,ltim)

      return
      end subroutine
!=======================================================================
!> @brief Initilise checkpointing module
!! @ingroup chkpoint
!! @note This routine should be called in frame_usr_init
      subroutine chkpt_init()
      implicit none

      include 'SIZE'
      include 'TSTEP'
      include 'FRAMELP'
      include 'CHKPOINTD'

      ! local variables
      integer itmp, lstdl
      real rtmp, ltim
      logical ltmp
      character*20 ctmp
      character*2 str
      character*200 lstring

      ! functions
      logical chkpts_is_initialised
      real dnekclock
!-----------------------------------------------------------------------
      ! check if the module was already initialised
      if (chpt_ifinit) then
         call mntr_warn(chpt_id,
     $        'module ['//trim(chpt_name)//'] already initiaised.')
         ! check submodule intialisation
         if (.not.chkpts_is_initialised()) then
            call mntr_abort(chpt_id,
     $        'required submodule module not initiaised.')
         endif
         return
      endif

      ! timing
      ltim = dnekclock()

      ! get runtime parameters
      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,chpt_ifrst_id,rpar_log)
      chpt_ifrst = ltmp
      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,chpt_fnum_id,rpar_int)
      chpt_fnum = itmp
      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,chpt_step_id,rpar_int)
      chpt_step = itmp

      if (chpt_ifrst) then
      ! get input set number
         chpt_set_i = chpt_fnum - 1
         if (chpt_set_i.ge.chpt_nset) then
            write(str,'(I2)') chpt_nset + 1
            lstring = 'chpt_fnum must be in the range: 1-'//trim(str)
            call mntr_abort(chpt_id,lstring)
         endif

         chpt_set_o = mod(chpt_set_i+1,chpt_nset)
      else
         chpt_set_o = 0
      endif

      ! set reset flag
      chpt_reset = -1

      ! check number of steps
      call mntr_get_step_delay(lstdl)
      if (NSTEPS.lt.3*lstdl) then
         call mntr_abort(chpt_id,'too short run for multi-file restart')
      endif

      ! check checkpoint frequency
      if (chpt_step.lt.2*lstdl.or.chpt_step.gt.NSTEPS) then
         chpt_step = NSTEPS
         call mntr_warn(chpt_id,'wrong chpt_step; resetting to NSTEPS')
      endif

      ! set min and max ISTEP for cyclic checkpoint writning
      ! timesteps outside this bouds require special treatment
      chpt_istep = lstdl
      chpt_nstep = NSTEPS - lstdl - 1
      ! check if chpt_nstep is in the middle of writing cycle
      itmp = chpt_nstep + chpt_step -1
      if (mod(itmp,chpt_step).ge.(chpt_step-lstdl)) then
         itmp = lstdl + mod(itmp,chpt_step) + 1 - chpt_step
         chpt_nstep = chpt_nstep - itmp
      endif

      ! call submodule initialisation
      call chkpts_init

      ! is everything initialised
      if (chkpts_is_initialised()) chpt_ifinit=.true.

      ! timing
      ltim = dnekclock() - ltim
      call mntr_tmr_add(chpt_tini_id,1,ltim)

      return
      end subroutine
!=======================================================================
!> @brief Check if module was initialised
!! @ingroup chkpoint
!! @return chkpt_is_initialised
      logical function chkpt_is_initialised()
      implicit none

      include 'SIZE'
      include 'CHKPOINTD'
!-----------------------------------------------------------------------
      chkpt_is_initialised = chpt_ifinit

      return
      end function
!=======================================================================
!> @brief Main checkpoint interface
!! @ingroup chkpoint
!! @note This routine should be called in userchk as a first framework call
!     after frame_monitor
      subroutine chkpt_main
      implicit none

      include 'SIZE'
      include 'TSTEP'
      include 'CHKPOINTD'

      ! local variables
      integer itmp, lstdl
!-----------------------------------------------------------------------
      if(chpt_ifrst.and.ISTEP.le.chpt_istep) then
         call chkpts_read
      elseif (ISTEP.gt.chpt_istep) then

      ! adjust max ISTEP for cyclic checkpoint writning
         call mntr_get_step_delay(lstdl)
         chpt_nstep = NSTEPS - lstdl -1
      ! check if chpt_nstep is in the middle of writing cycle
         itmp = chpt_nstep + chpt_step -1
         if (mod(itmp,chpt_step).ge.(chpt_step-lstdl)) then
            itmp = lstdl + mod(itmp,chpt_step) + 1 - chpt_step
            chpt_nstep = chpt_nstep - itmp
         endif

      ! count steps to the end of wrting stage
         itmp = ISTEP + chpt_step -1
         if (ISTEP.gt.(NSTEPS-lstdl)) then
            chpt_stepc = NSTEPS-ISTEP+1
         elseif (ISTEP.lt.chpt_nstep.and.
     $    mod(itmp,chpt_step).ge.(chpt_step-lstdl)) then
            chpt_stepc = chpt_step - mod(itmp,chpt_step)
         else
            chpt_stepc = -1
         endif

      ! get the checkpoint set number
      ! to avoid conflicts with dependent packages I reset chpt_set_o
      ! during the step after checkpointing
         if (ISTEP.lt.chpt_nstep.and.mod(ISTEP,chpt_step).eq.0) then
            chpt_reset = mod(chpt_set_o+1,chpt_nset)
         elseif (chpt_reset.ge.0) then
            chpt_set_o = chpt_reset
            chpt_reset = -1
         endif

         call chkpts_write
      endif

      return
      end subroutine
!=======================================================================
!> @brief Get step count to the checkpoint and a set number
!! @ingroup chkpoint
!! @param[out] step_cnt   decreasing step count in checkpoint writinh phase (otherwise -1)
!! @param[out] set_out    set number
      subroutine chkpt_get_fset(step_cnt, set_out)
      implicit none

      include 'SIZE'
      include 'CHKPOINTD'

      ! argument list
      integer step_cnt, set_out
!-----------------------------------------------------------------------
      step_cnt = chpt_stepc
      set_out  = chpt_set_o

      return
      end subroutine
!=======================================================================






!> @file spongebx.f
!! @ingroup sponge_box
!! @brief Sponge/fringe for simple box mesh
!! @author Adam Peplinski
!! @date Feb 1, 2017
!=======================================================================
!> @brief Register sponge_box module
!! @ingroup sponge_box
!! @note This routine should be called in frame_usr_register
      subroutine spng_register()
      implicit none

      include 'SIZE'
      include 'INPUT'
      include 'FRAMELP'
      include 'SPONGEBXD'

      ! local variables
      integer lpmid
      real ltim

      ! functions
      real dnekclock
!-----------------------------------------------------------------------
      ! timing
      ltim = dnekclock()

      ! check if the current module was already registered
      call mntr_mod_is_name_reg(lpmid,spng_name)
      if (lpmid.gt.0) then
         call mntr_warn(lpmid,
     $        'module ['//trim(spng_name)//'] already registered')
         return
      endif

      ! find parent module
      call mntr_mod_is_name_reg(lpmid,'FRAME')
      if (lpmid.le.0) then
         lpmid = 1
         call mntr_abort(lpmid,
     $        'Parent module ['//'FRAME'//'] not registered')
      endif

      ! register module
      call mntr_mod_reg(spng_id,lpmid,spng_name,
     $          'Sponge/fringe for rectangular domain')

      ! register timer
      call mntr_tmr_is_name_reg(lpmid,'FRM_TOT')
      call mntr_tmr_reg(spng_tmr_id,lpmid,spng_id,
     $     'SPNG_INI','Sponge calculation initialisation time',.false.)

      ! register and set active section
      call rprm_sec_reg(spng_sec_id,spng_id,'_'//adjustl(spng_name),
     $     'Runtime paramere section for sponge_box module')
      call rprm_sec_set_act(.true.,spng_sec_id)

      ! register parameters
      call rprm_rp_reg(spng_str_id,spng_sec_id,'STRENGTH',
     $     'Sponge strength',rpar_real,0,0.0,.false.,' ')

      call rprm_rp_reg(spng_wl_id(1),spng_sec_id,'WIDTHLX',
     $     'Sponge left section width; dimension X ',
     $     rpar_real,0,0.0,.false.,' ')

      call rprm_rp_reg(spng_wl_id(2),spng_sec_id,'WIDTHLY',
     $     'Sponge left section width; dimension Y ',
     $     rpar_real,0,0.0,.false.,' ')

      if (IF3D) call rprm_rp_reg(spng_wl_id(ndim),spng_sec_id,
     $     'WIDTHLZ','Sponge left section width; dimension Z ',
     $     rpar_real,0,0.0,.false.,' ')

      call rprm_rp_reg(spng_wr_id(1),spng_sec_id,'WIDTHRX',
     $     'Sponge right section width; dimension X ',
     $     rpar_real,0,0.0,.false.,' ')

      call rprm_rp_reg(spng_wr_id(2),spng_sec_id,'WIDTHRY',
     $     'Sponge right section width; dimension Y ',
     $     rpar_real,0,0.0,.false.,' ')

      if (IF3D) call rprm_rp_reg(spng_wr_id(ndim),spng_sec_id,
     $     'WIDTHRZ','Sponge right section width; dimension Z ',
     $     rpar_real,0,0.0,.false.,' ')

      call rprm_rp_reg(spng_dl_id(1),spng_sec_id,'DROPLX',
     $     'Sponge left drop/rise section width; dimension X ',
     $     rpar_real,0,0.0,.false.,' ')

      call rprm_rp_reg(spng_dl_id(2),spng_sec_id,'DROPLY',
     $     'Sponge left drop/rise section width; dimension Y ',
     $     rpar_real,0,0.0,.false.,' ')

      if (IF3D) call rprm_rp_reg(spng_dl_id(ndim),spng_sec_id,
     $    'DROPLZ','Sponge left drop/rise section width; dimension Z ',
     $    rpar_real,0,0.0,.false.,' ')

      call rprm_rp_reg(spng_dr_id(1),spng_sec_id,'DROPRX',
     $     'Sponge right drop/rise section width; dimension X ',
     $     rpar_real,0,0.0,.false.,' ')

      call rprm_rp_reg(spng_dr_id(2),spng_sec_id,'DROPRY',
     $     'Sponge right drop/rise section width; dimension Y ',
     $     rpar_real,0,0.0,.false.,' ')

      if (IF3D) call rprm_rp_reg(spng_dr_id(ndim),spng_sec_id,
     $   'DROPRZ','Sponge right drop/rise section width; dimension Z ',
     $    rpar_real,0,0.0,.false.,' ')

      ! timing
      ltim = dnekclock() - ltim
      call mntr_tmr_add(spng_tmr_id,1,ltim)

      return
      end subroutine
!=======================================================================
!> @brief Initilise sponge_box module
!! @ingroup sponge_box
!! @param[in] lvx, lvy, lvz   velocity field to be stored as reference field
!! @note This routine should be called in frame_usr_init
!! @remark This routine uses global scratch space \a SCRUZ
      subroutine spng_init(lvx,lvy,lvz)
      implicit none

      include 'SIZE'
      include 'INPUT'
      include 'GEOM'
      include 'FRAMELP'
      include 'SPONGEBXD'

      ! argument list
      real lvx(LX1*LY1*LZ1*LELV),lvy(LX1*LY1*LZ1*LELV)
      real lvz(LX1*LY1*LZ1*LELV)

      ! local variables
      integer ierr, nhour, nmin
      integer itmp
      real rtmp, ltim
      logical ltmp
      character*20 ctmp

      integer ntot, il, jl
      real bmin(LDIM), bmax(LDIM)

      real xxmax, xxmax_c, xxmin, xxmin_c, arg
      real lcoord(LX1*LY1*LZ1*LELV)
      common /SCRUZ/ lcoord

      ! functions
      real dnekclock, glmin, glmax, mth_stepf
!-----------------------------------------------------------------------
      ! check if the module was already initialised
      if (spng_ifinit) then
         call mntr_warn(spng_id,
     $        'module ['//trim(spng_name)//'] already initiaised.')
         return
      endif

      ! timing
      ltim = dnekclock()

      ! get runtime parameters
      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,spng_str_id,rpar_real)
      spng_str = rtmp

      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,spng_wl_id(1),rpar_real)
      spng_wl(1) = rtmp

      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,spng_wl_id(2),rpar_real)
      spng_wl(2) = rtmp

      if (IF3D) then
         call rprm_rp_get(itmp,rtmp,ltmp,ctmp,spng_wl_id(ndim),
     $        rpar_real)
         spng_wl(ndim) = rtmp
      endif

      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,spng_wr_id(1),rpar_real)
      spng_wr(1) = rtmp

      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,spng_wr_id(2),rpar_real)
      spng_wr(2) = rtmp

      if (IF3D) then
         call rprm_rp_get(itmp,rtmp,ltmp,ctmp,spng_wr_id(ndim),
     $        rpar_real)
         spng_wr(ndim) = rtmp
      endif

      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,spng_dl_id(1),rpar_real)
      spng_dl(1) = rtmp

      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,spng_dl_id(2),rpar_real)
      spng_dl(2) = rtmp

      if (IF3D) then
         call rprm_rp_get(itmp,rtmp,ltmp,ctmp,spng_dl_id(ndim),
     $        rpar_real)
         spng_dl(ndim) = rtmp
      endif

      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,spng_dr_id(1),rpar_real)
      spng_dr(1) = rtmp

      call rprm_rp_get(itmp,rtmp,ltmp,ctmp,spng_dr_id(2),rpar_real)
      spng_dr(2) = rtmp

      if (IF3D) then
         call rprm_rp_get(itmp,rtmp,ltmp,ctmp,spng_dr_id(ndim),
     $        rpar_real)
         spng_dr(ndim) = rtmp
      endif

      ! initialise sponge variables

      ! get box size
      ntot = NX1*NY1*NZ1*NELV
      bmin(1) = glmin(XM1,ntot)
      bmax(1) = glmax(XM1,ntot)
      bmin(2) = glmin(YM1,ntot)
      bmax(2) = glmax(YM1,ntot)
      if(IF3D) then
         bmin(NDIM) = glmin(ZM1,ntot)
         bmax(NDIM) = glmax(ZM1,ntot)
      endif

      ! zero spng_fun
      call rzero(spng_fun,ntot)


      if(spng_str.gt.0.0) then
         call mntr_log(spng_id,lp_inf,"Sponge turned on")

         ! save reference field
         call copy(spng_vr(1,1),lvx, ntot)
         call copy(spng_vr(1,2),lvy, ntot)
         if (IF3D) call copy(spng_vr(1,NDIM),lvz, ntot)

         ! for every dimension
         do il=1,NDIM

            if (spng_wl(il).gt.0.0.or.spng_wr(il).gt.0.0) then
               if (spng_wl(il).lt.spng_dl(il).or.
     $              spng_wr(il).lt.spng_dr(il)) then
                  call mntr_abort(spng_id,"Wrong sponge parameters")
               endif

               ! sponge beginning (rise at xmax; right)
               xxmax = bmax(il) - spng_wr(il)
               ! end (drop at xmin; left)
               xxmin = bmin(il) + spng_wl(il)
               ! beginnign of constant part (right)
               xxmax_c = xxmax + spng_dr(il)
               ! beginnign of constant part (left)
               xxmin_c = xxmin - spng_dl(il)

               ! get SPNG_FUN
               if (xxmax.le.xxmin) then
                  call mntr_abort(spng_id,"Sponge too wide")
               else
                  ! this should be done by pointers, but for now I avoid it
                  if (il.eq.1) then
                     call copy(lcoord,XM1, ntot)
                  elseif (il.eq.2) then
                     call copy(lcoord,YM1, ntot)
                  elseif (il.eq.3) then
                     call copy(lcoord,ZM1, ntot)
                  endif

                  do jl=1,ntot
                     rtmp = lcoord(jl)
                     if(rtmp.le.xxmin_c) then ! constant; xmin
                        rtmp=spng_str
                     elseif(rtmp.lt.xxmin) then ! fall; xmin
                        arg = (xxmin-rtmp)/spng_wl(il)
                        rtmp = mth_stepf(arg)
                     elseif (rtmp.le.xxmax) then ! zero
                        rtmp = 0.0
                     elseif (rtmp.lt.xxmax_c) then ! rise
                        arg = (rtmp-xxmax)/spng_wr(il)
                        rtmp = mth_stepf(arg)
                     else    ! constant
                        rtmp = spng_str
                     endif
                     spng_fun(jl)=max(spng_fun(jl),rtmp)
                  enddo

               endif         ! xxmax.le.xxmin

            endif            ! spng_w(il).gt.0.0
         enddo


      endif

#ifdef DEBUG
      ! for debugging
      ltmp = ifto
      ifto = .TRUE.
      call outpost2(spng_vr,spng_vr(1,2),spng_vr(1,NDIM),spng_fun,
     $              spng_fun,1,'spg')
      ifto = ltmp
#endif

      ! is everything initialised
      spng_ifinit=.true.

      ! timing
      ltim = dnekclock() - ltim
      call mntr_tmr_add(spng_tmr_id,1,ltim)

      return
      end subroutine
!=======================================================================
!> @brief Check if module was initialised
!! @ingroup sponge_box
!! @return spng_is_initialised
      logical function spng_is_initialised()
      implicit none

      include 'SIZE'
      include 'SPONGEBXD'
!-----------------------------------------------------------------------
      spng_is_initialised = spng_ifinit

      return
      end function
!=======================================================================
!> @brief Get sponge forcing
!! @ingroup sponge_box
!! @param[inout] ffx,ffy,ffz     forcing; x,y,z component
!! @param[in]    ix,iy,iz        GLL point index
!! @param[in]    ieg             global element number
      subroutine spng_forcing(ffx,ffy,ffz,ix,iy,iz,ieg)
      implicit none

      include 'SIZE'            !
      include 'INPUT'           ! IF3D
      include 'PARALLEL'        ! GLLEL
      include 'SOLN'            ! JP
      include 'SPONGEBXD'

      ! argument list
      real ffx, ffy, ffz
      integer ix,iy,iz,ieg

      ! local variables
      integer iel, ip
!-----------------------------------------------------------------------
      iel=GLLEL(ieg)
      if (SPNG_STR.gt.0.0) then
         ip=ix+NX1*(iy-1+NY1*(iz-1+NZ1*(iel-1)))

         if (JP.eq.0) then
            ! dns
            ffx = ffx + SPNG_FUN(ip)*(SPNG_VR(ip,1) - VX(ix,iy,iz,iel))
            ffy = ffy + SPNG_FUN(ip)*(SPNG_VR(ip,2) - VY(ix,iy,iz,iel))
            if (IF3D) ffz = ffz + SPNG_FUN(ip)*
     $           (SPNG_VR(ip,NDIM) - VZ(ix,iy,iz,iel))
         else
            ! perturbation
            ffx = ffx - SPNG_FUN(ip)*VXP(ip,JP)
            ffy = ffy - SPNG_FUN(ip)*VYP(ip,JP)
            if(IF3D) ffz = ffz - SPNG_FUN(ip)*VZP(ip,JP)
         endif

      endif

      return
      end subroutine
!=======================================================================
!> @file math_tools.f
!! @ingroup math
!! @brief Set of math related tools for KTH modules
!! @author Adam Peplinski
!! @date Jan 31, 2017
!=======================================================================
!> @brief Step function
!! @ingroup math
!! @details Continuous step function:
!!  \f{eqnarray*}{
!!    stepf(x) = \left\{ \begin{array}{ll}
!!  0 &\mbox{ if $x \leq x_{min}$} \\
!!  \left(1+e^{\left((x-1)^{-1} + x^{-1}\right)}\right)^{-1} &\mbox{ if $x \leq x_{max}$} \\
!!  1 &\mbox{ if $x >  x_{max}$}
!!       \end{array} \right.
!!  \f}
!!  with \f$ x_{min} = 0.02\f$ and \f$ x_{max}=0.98\f$
!! @param[in] x       function argument
!! @return mth_stepf
      real function mth_stepf(x)
      implicit none

      ! argument list
      real x

      ! local variables
      real xdmin, xdmax
      parameter (xdmin = 0.001, xdmax = 0.999)
!-----------------------------------------------------------------------
      ! get function vale
      if (x.le.xdmin) then
         mth_stepf = 0.0
      else if (x.le.xdmax) then
         mth_stepf = 1./( 1. + exp(1./(x - 1.) + 1./x) )
      else
         mth_stepf = 1.
      end if

      end function mth_stepf
!=======================================================================
!> @brief Give random distribution depending on position
!! @ingroup math
!! @details The original Nek5000 rundom number generator is implementted
!!  in @ref ran1. This totally ad-hoc random number generator below
!!  could be preferable to the origina one for the simple reason that it
!!  gives the same initial cindition independent of the number of
!!  processors, which is important for code verification.
!! @param[in] ix,iy,iz     GLL point index
!! @param[in] ieg          global element number
!! @param[in] xl           physical point coordinates
!! @param[in] fcoeff       function coefficients
!! @return  random distribution
      real function mth_rand(ix,iy,iz,ieg,xl,fcoeff)
      implicit none

      include 'SIZE'
      include 'INPUT'       ! IF3D

      ! argument list
      integer ix,iy,iz,ieg
      real xl(LDIM)
      real fcoeff(3)
!-----------------------------------------------------------------------
      mth_rand = fcoeff(1)*(ieg+xl(1)*sin(xl(2))) + fcoeff(2)*ix*iy +
     $     fcoeff(3)*ix
      if (IF3D) mth_rand = fcoeff(1)*(ieg +xl(NDIM)*sin(mth_rand)) +
     $     fcoeff(2)*iz*ix + fcoeff(3)*iz
      mth_rand = 1.e3*sin(mth_rand)
      mth_rand = 1.e3*sin(mth_rand)
      mth_rand = cos(mth_rand)

      return
      end function mth_rand
!=======================================================================
